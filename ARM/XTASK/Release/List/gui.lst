##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.40A/W32 EVALUATION    24/Sep/2006  17:29:18 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  E:\ARM\XTASK\gui.c                                   #
#    Command line    =  E:\ARM\XTASK\gui.c -lC E:\ARM\XTASK\Release\List\    #
#                       -o E:\ARM\XTASK\Release\Obj\ -s9 --no_unroll         #
#                       --no_clustering --cpu_mode arm --endian little       #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --fpu None -I D:\IARARM\ARM\INC\                     #
#    List file       =  E:\ARM\XTASK\Release\List\gui.lst                    #
#    Object file     =  E:\ARM\XTASK\Release\Obj\gui.r79                     #
#                                                                            #
#                                                                            #
##############################################################################

E:\ARM\XTASK\gui.c
      1          #include "..\swilib.h"
      2          
      3          extern int mode;
      4          extern CSM_RAM *under_idle;
      5          
      6          const CSM_DESC maincsm;
      7          
      8          typedef struct
      9          {
     10            CSM_RAM csm;
     11            int gui_id;
     12          }MAIN_CSM;
     13          
     14          typedef struct
     15          {
     16            GUI gui;
     17            WSHDR *ws1;
     18            WSHDR *ws2;
     19            //  int i1;
     20          }MAIN_GUI;
     21          

   \                                 In segment DATA_Z, align 4, align-sorted
     22          int my_csm_id;
   \                     my_csm_id:
   \   00000000                      DS8 4
     23          

   \                                 In segment DATA_Z, align 4, align-sorted
     24          int cursor;
   \                     cursor:
   \   00000000                      DS8 4

   \                                 In segment DATA_Z, align 4, align-sorted
     25          void * volatile selcsm;
   \                     selcsm:
   \   00000000                      DS8 4
     26          
     27          typedef struct
     28          {
     29            void *next;
     30            WSHDR *name;
     31            void *p;
     32          } NAMELIST;
     33          

   \                                 In segment DATA_Z, align 4, align-sorted
     34          NAMELIST * volatile nltop;
   \                     nltop:
   \   00000000                      DS8 4

   \                                 In segment DATA_Z, align 4, align-sorted
     35          NAMELIST * volatile nlbot;
   \                     nlbot:
   \   00000000                      DS8 4
     36          

   \                                 In segment DATA_Z, align 4, align-sorted
     37          char csm_text[32768];
   \                     csm_text:
   \   00000000                      DS8 32768
     38          

   \                                 In segment DATA_C, align 1, align-sorted
     39          const char percent_t[]="%t";
   \                     percent_t:
   \   00000000   257400             DC8 "%t"
     40          

   \                                 In segment CODE, align 4, keep-with-next
     41          void ClearNL(void)
     42          {
   \                     ClearNL:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
     43            LockSched();
   \   00000004   460100EF           SWI      +326
     44            NAMELIST *nl=nltop;
   \   00000008   ........           LDR      R0,??DataTable12  ;; nltop
     45            nltop=0;
   \   0000000C   0010A0E3           MOV      R1,#+0
   \   00000010   004090E5           LDR      R4,[R0, #+0]
   \   00000014   001080E5           STR      R1,[R0, #+0]
     46            nlbot=0;
   \   00000018   ........           LDR      R0,??DataTable3  ;; nlbot
   \   0000001C   001080E5           STR      R1,[R0, #+0]
     47            UnlockSched();
   \   00000020   470100EF           SWI      +327
   \   00000024   000054E3           CMP      R4,#+0
   \   00000028   3080BD08           POPEQ    {R4,R5,PC}
     48            while(nl)
     49            {
     50              NAMELIST *p=nl;
     51              FreeWS(nl->name);
   \                     ??ClearNL_0:
   \   0000002C   040094E5           LDR      R0,[R4, #+4]
   \   00000030   0450A0E1           MOV      R5,R4
   \   00000034   290100EF           SWI      +297
     52              nl=p->next;
   \   00000038   004095E5           LDR      R4,[R5, #+0]
     53              mfree(p);
   \   0000003C   0500A0E1           MOV      R0,R5
   \   00000040   150000EF           SWI      +21
     54            }
   \   00000044   000054E3           CMP      R4,#+0
   \   00000048   F7FFFF1A           BNE      ??ClearNL_0
     55          }
   \   0000004C   3080BDE8           POP      {R4,R5,PC}       ;; return
     56          

   \                                 In segment CODE, align 4, keep-with-next
     57          void AddNL(WSHDR *ws)
     58          {
   \                     AddNL:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
     59            NAMELIST *nnl=malloc(sizeof(NAMELIST));
   \   00000008   0C00A0E3           MOV      R0,#+12
   \   0000000C   140000EF           SWI      +20
   \   00000010   0050A0E1           MOV      R5,R0
     60            nnl->name=ws;
   \   00000014   044085E5           STR      R4,[R5, #+4]
     61            nnl->next=0;
   \   00000018   0000A0E3           MOV      R0,#+0
   \   0000001C   000085E5           STR      R0,[R5, #+0]
     62            LockSched();
   \   00000020   460100EF           SWI      +326
     63            if (!nltop)
   \   00000024   ........           LDR      R0,??DataTable12  ;; nltop
   \   00000028   001090E5           LDR      R1,[R0, #+0]
   \   0000002C   000051E3           CMP      R1,#+0
     64            {
     65              nlbot=nltop=nnl;
   \   00000030   00508005           STREQ    R5,[R0, #+0]
   \   00000034   ........           LDREQ    R0,??DataTable3  ;; nlbot
     66            }
     67            else
     68            {
     69              nnl->next=nltop;
   \   00000038   00109015           LDRNE    R1,[R0, #+0]
   \   0000003C   00108515           STRNE    R1,[R5, #+0]
     70              nltop=nnl;
   \   00000040   005080E5           STR      R5,[R0, #+0]
     71            }
     72            UnlockSched();
   \   00000044   470100EF           SWI      +327
   \   00000048   3080BDE8           POP      {R4,R5,PC}       ;; return
     73          }
     74          

   \                                 In segment CODE, align 4, keep-with-next
     75          char *find_name(CSM_RAM *csm)
     76          {
     77            char s[40];
     78            char *p;
     79            static char u[40];
     80          
     81            CSM_DESC *desc=csm->constr;
     82          
     83            sprintf(s,"%08X ",desc);
   \                     find_name:
   \   00000000   4C109FE5           LDR      R1,??find_name_0  ;; `?<Constant "%08X ">`
   \   00000004   30402DE9           PUSH     {R4,R5,LR}
   \   00000008   28D04DE2           SUB      SP,SP,#+40
   \   0000000C   084090E5           LDR      R4,[R0, #+8]
   \   00000010   0D00A0E1           MOV      R0,SP
   \   00000014   0420A0E1           MOV      R2,R4
   \   00000018   160000EF           SWI      +22
     84            p=strstr(csm_text,s);
   \   0000001C   ........           LDR      R0,??DataTable16  ;; csm_text
   \   00000020   0D10A0E1           MOV      R1,SP
   \   00000024   180100EF           SWI      +280
     85            if (p)
   \   00000028   000050E3           CMP      R0,#+0
     86            {
     87              return(p+9);
   \   0000002C   09008012           ADDNE    R0,R0,#+9
   \   00000030   0500001A           BNE      ??find_name_1
     88            }
     89            else
     90            {
     91              sprintf(u,"Unknown %08X!",desc);
   \   00000034   1C509FE5           LDR      R5,??find_name_0+0x4  ;; ??u
   \   00000038   1C109FE5           LDR      R1,??find_name_0+0x8  ;; `?<Constant "Unknown %08X!">`
   \   0000003C   0420A0E1           MOV      R2,R4
   \   00000040   0500A0E1           MOV      R0,R5
   \   00000044   160000EF           SWI      +22
     92              return(u);
   \   00000048   0500A0E1           MOV      R0,R5
   \                     ??find_name_1:
   \   0000004C   28D08DE2           ADD      SP,SP,#+40       ;; stack cleaning
   \   00000050   3080BDE8           POP      {R4,R5,PC}       ;; return
   \                     ??find_name_0:
   \   00000054   ........           DC32     `?<Constant "%08X ">`
   \   00000058   ........           DC32     ??u
   \   0000005C   ........           DC32     `?<Constant "Unknown %08X!">`
     93            }
     94          }

   \                                 In segment DATA_Z, align 4, align-sorted
   \                     ??u:
   \   00000000                      DS8 40
     95          

   \                                 In segment CODE, align 4, keep-with-next
     96          int GetNumberOfDialogs(void)
     97          {
     98            int count=0;
     99            CSM_RAM *icsm=under_idle->next; //Начало карусели
   \                     GetNumberOfDialogs:
   \   00000000   ........           LDR      R0,??DataTable10  ;; under_idle
   \   00000004   F0432DE9           PUSH     {R4-R9,LR}
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   ........           LDR      R7,??DataTable12  ;; nltop
   \   00000010   004090E5           LDR      R4,[R0, #+0]
    100            ClearNL();
   \   00000014   ........           BL       ClearNL
    101            WSHDR *ws;
    102          
    103            void *ircsm=FindCSMbyID(CSM_root()->idle_id);
   \   00000018   068100EF           SWI      +33030
   \   0000001C   040090E5           LDR      R0,[R0, #+4]
   \   00000020   0080A0E3           MOV      R8,#+0
   \   00000024   080100EF           SWI      +264
   \   00000028   0050A0E1           MOV      R5,R0
    104          
    105            do
    106            {
    107              if (icsm==ircsm)
   \                     ??GetNumberOfDialogs_0:
   \   0000002C   016088E2           ADD      R6,R8,#+1
   \   00000030   050054E1           CMP      R4,R5
   \   00000034   0500001A           BNE      ??GetNumberOfDialogs_1
    108              {
    109                ws=AllocWS(40);
   \   00000038   2800A0E3           MOV      R0,#+40
   \   0000003C   250100EF           SWI      +293
    110                wsprintf(ws,"IDLE Screen");
   \   00000040   B4109FE5           LDR      R1,??GetNumberOfDialogs_2  ;; `?<Constant "IDLE Screen">`
   \   00000044   0080A0E1           MOV      R8,R0
   \   00000048   240100EF           SWI      +292
   \   0000004C   200000EA           B        ??GetNumberOfDialogs_3
    111                AddNL(ws);
    112                nltop->p=icsm;
    113                count++;
    114              }
    115              else
    116              {
    117                if (icsm->constr!=&maincsm)
   \                     ??GetNumberOfDialogs_1:
   \   00000050   080094E5           LDR      R0,[R4, #+8]
   \   00000054   ........           LDR      R1,??DataTable22  ;; maincsm
   \   00000058   010050E1           CMP      R0,R1
   \   0000005C   2100000A           BEQ      ??GetNumberOfDialogs_4
    118                {
    119          	WSHDR *tws=(WSHDR *)(((char *)icsm->constr)+sizeof(CSM_DESC));
    120          	char *s;
    121          	if((tws->ws_malloc==NAMECSM_MAGIC1)&&(tws->ws_mfree==NAMECSM_MAGIC2))
   \   00000060   98109FE5           LDR      R1,??GetNumberOfDialogs_2+0x4  ;; 0x55aacccc
   \   00000064   289080E2           ADD      R9,R0,#+40
   \   00000068   040099E5           LDR      R0,[R9, #+4]
   \   0000006C   010050E1           CMP      R0,R1
   \   00000070   0900001A           BNE      ??GetNumberOfDialogs_5
   \   00000074   080099E5           LDR      R0,[R9, #+8]
   \   00000078   84109FE5           LDR      R1,??GetNumberOfDialogs_2+0x8  ;; 0x3333aa55
   \   0000007C   010050E1           CMP      R0,R1
   \   00000080   0500001A           BNE      ??GetNumberOfDialogs_5
    122          	{
    123          	  ws=AllocWS(40);
   \   00000084   2800A0E3           MOV      R0,#+40
   \   00000088   250100EF           SWI      +293
   \   0000008C   0080A0E1           MOV      R8,R0
    124          	  wstrcpy(ws,tws);
   \   00000090   0910A0E1           MOV      R1,R9
   \   00000094   1F0100EF           SWI      +287
   \   00000098   0D0000EA           B        ??GetNumberOfDialogs_3
    125          	  AddNL(ws);
    126          	  nltop->p=icsm;
    127          	  count++;
    128          	}
    129          	else
    130          	{
    131          	  s=find_name(icsm);
   \                     ??GetNumberOfDialogs_5:
   \   0000009C   0400A0E1           MOV      R0,R4
   \   000000A0   ........           BL       find_name
    132          	  if (strncmp(s,"!SKIP!",6))
   \   000000A4   5C109FE5           LDR      R1,??GetNumberOfDialogs_2+0xC  ;; `?<Constant "!SKIP!">`
   \   000000A8   0090A0E1           MOV      R9,R0
   \   000000AC   0620A0E3           MOV      R2,#+6
   \   000000B0   150100EF           SWI      +277
   \   000000B4   000050E3           CMP      R0,#+0
   \   000000B8   0A00000A           BEQ      ??GetNumberOfDialogs_4
    133          	  {
    134          	    ws=AllocWS(40);
   \   000000BC   2800A0E3           MOV      R0,#+40
   \   000000C0   250100EF           SWI      +293
    135          	    wsprintf(ws,percent_t,s);
   \   000000C4   ........           LDR      R1,??DataTable15  ;; percent_t
   \   000000C8   0080A0E1           MOV      R8,R0
   \   000000CC   0920A0E1           MOV      R2,R9
   \   000000D0   240100EF           SWI      +292
    136          	    AddNL(ws);
   \                     ??GetNumberOfDialogs_3:
   \   000000D4   0800A0E1           MOV      R0,R8
   \   000000D8   ........           BL       AddNL
    137          	    nltop->p=icsm;
   \   000000DC   000097E5           LDR      R0,[R7, #+0]
    138          	    count++;
   \   000000E0   0680A0E1           MOV      R8,R6
   \   000000E4   084080E5           STR      R4,[R0, #+8]
    139          	  }
    140          	}
    141                }
    142              }
    143            }
    144            while((icsm=icsm->next));
   \                     ??GetNumberOfDialogs_4:
   \   000000E8   004094E5           LDR      R4,[R4, #+0]
   \   000000EC   000054E3           CMP      R4,#+0
   \   000000F0   CDFFFF1A           BNE      ??GetNumberOfDialogs_0
    145            return(count);
   \   000000F4   0800A0E1           MOV      R0,R8
   \   000000F8   F083BDE8           POP      {R4-R9,PC}       ;; return
   \                     ??GetNumberOfDialogs_2:
   \   000000FC   ........           DC32     `?<Constant "IDLE Screen">`
   \   00000100   CCCCAA55           DC32     0x55aacccc
   \   00000104   55AA3333           DC32     0x3333aa55
   \   00000108   ........           DC32     `?<Constant "!SKIP!">`
    146          }
    147          

   \                                 In segment CODE, align 4, keep-with-next
    148          void SwapCSMS(void)
    149          {
   \                     SwapCSMS:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    150            CSM_RAM *icsm; //Нижний CSM
    151            CSM_RAM *ucsm; //Верхний CSM
    152            CSM_RAM *wcsm; //Перемещаемый CSM
    153            extern WSHDR *ws_nogui;
    154          
    155            if (GetNumberOfDialogs()<2) return; //Нечего сворачивать
   \   00000004   ........           BL       GetNumberOfDialogs
   \   00000008   020050E3           CMP      R0,#+2
   \   0000000C   3080BDB8           POPLT    {R4,R5,PC}
    156            if (!selcsm) return;
   \   00000010   ........           LDR      R4,??DataTable20  ;; selcsm
   \   00000014   000094E5           LDR      R0,[R4, #+0]
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   3080BD08           POPEQ    {R4,R5,PC}
    157            do
    158            {
    159              icsm=under_idle;
   \                     ??SwapCSMS_0:
   \   00000020   ........           LDR      R0,??DataTable10  ;; under_idle
   \   00000024   005090E5           LDR      R5,[R0, #+0]
    160              ucsm=FindCSMbyID(my_csm_id);
   \   00000028   ........           LDR      R0,??DataTable23  ;; my_csm_id
   \   0000002C   000090E5           LDR      R0,[R0, #+0]
   \   00000030   080100EF           SWI      +264
    161              wcsm=(CSM_RAM *)ucsm->prev; //Получаем перемещаемый CSM
   \   00000034   041090E5           LDR      R1,[R0, #+4]
    162              ((CSM_RAM *)(wcsm->prev))->next=ucsm; //CSM перед перемещаемым теперь указывает на верхний CSM
   \   00000038   042091E5           LDR      R2,[R1, #+4]
   \   0000003C   000082E5           STR      R0,[R2, #+0]
    163              ucsm->prev=wcsm->prev; //prev верхнего CSM указывает на CSM перед перемещаемым
   \   00000040   042091E5           LDR      R2,[R1, #+4]
   \   00000044   042080E5           STR      R2,[R0, #+4]
    164              //Теперь вставляем в нужное место перемещаемый CSM
    165              ((CSM_RAM *)(wcsm->next=icsm->next))->prev=wcsm;
   \   00000048   002095E5           LDR      R2,[R5, #+0]
   \   0000004C   002081E5           STR      R2,[R1, #+0]
   \   00000050   041082E5           STR      R1,[R2, #+4]
    166              icsm->next=wcsm;
   \   00000054   001085E5           STR      R1,[R5, #+0]
    167              wcsm->prev=icsm;
   \   00000058   045081E5           STR      R5,[R1, #+4]
    168            }
    169            while(ucsm->prev!=selcsm);
   \   0000005C   040090E5           LDR      R0,[R0, #+4]
   \   00000060   001094E5           LDR      R1,[R4, #+0]
   \   00000064   010050E1           CMP      R0,R1
   \   00000068   ECFFFF1A           BNE      ??SwapCSMS_0
    170            //Теперь рисуем "Нет GUI" на всякий случай
    171            DrawRoundedFrame(0,0,131,175,0,0,0,
    172          			GetPaletteAdrByColorIndex(0),
    173          			GetPaletteAdrByColorIndex(20));
   \   0000006C   1400A0E3           MOV      R0,#+20
   \   00000070   2E0100EF           SWI      +302
   \   00000074   0040A0E1           MOV      R4,R0
   \   00000078   0000A0E3           MOV      R0,#+0
   \   0000007C   2E0100EF           SWI      +302
   \   00000080   10002DE9           PUSH     {R4}
   \   00000084   01002DE9           PUSH     {R0}
   \   00000088   AF30A0E3           MOV      R3,#+175
   \   0000008C   8320A0E3           MOV      R2,#+131
   \   00000090   0010A0E3           MOV      R1,#+0
   \   00000094   0000A0E3           MOV      R0,#+0
   \   00000098   01002DE9           PUSH     {R0}
   \   0000009C   01002DE9           PUSH     {R0}
   \   000000A0   01002DE9           PUSH     {R0}
   \   000000A4   500100EF           SWI      +336
    174            DrawString(ws_nogui,3,70,128,172,1,2,GetPaletteAdrByColorIndex(2),GetPaletteAdrByColorIndex(23));
   \   000000A8   1700A0E3           MOV      R0,#+23
   \   000000AC   2E0100EF           SWI      +302
   \   000000B0   0040A0E1           MOV      R4,R0
   \   000000B4   0200A0E3           MOV      R0,#+2
   \   000000B8   2E0100EF           SWI      +302
   \   000000BC   10002DE9           PUSH     {R4}
   \   000000C0   01002DE9           PUSH     {R0}
   \   000000C4   8030A0E3           MOV      R3,#+128
   \   000000C8   4620A0E3           MOV      R2,#+70
   \   000000CC   0310A0E3           MOV      R1,#+3
   \   000000D0   0200A0E3           MOV      R0,#+2
   \   000000D4   01002DE9           PUSH     {R0}
   \   000000D8   0100A0E3           MOV      R0,#+1
   \   000000DC   01002DE9           PUSH     {R0}
   \   000000E0   AC00A0E3           MOV      R0,#+172
   \   000000E4   01002DE9           PUSH     {R0}
   \   000000E8   0C009FE5           LDR      R0,??SwapCSMS_1  ;; ws_nogui
   \   000000EC   000090E5           LDR      R0,[R0, #+0]
   \   000000F0   4C0100EF           SWI      +332
   \   000000F4   28D08DE2           ADD      SP,SP,#+40
   \   000000F8   3080BDE8           POP      {R4,R5,PC}       ;; return
   \                     ??SwapCSMS_1:
   \   000000FC   ........           DC32     ws_nogui
    175          }
    176          
    177          

   \                                 In segment CODE, align 4, keep-with-next
    178          void method0(MAIN_GUI *data)
    179          {
   \                     method0:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    180            int i;
    181            int pos;
    182            int vcur;
    183            NAMELIST *nl;
    184          
    185            DrawRoundedFrame(0,0,131,175,0,0,0,
    186          			GetPaletteAdrByColorIndex(0),
    187          			GetPaletteAdrByColorIndex(20));
   \   00000008   1400A0E3           MOV      R0,#+20
   \   0000000C   2E0100EF           SWI      +302
   \   00000010   0050A0E1           MOV      R5,R0
   \   00000014   0000A0E3           MOV      R0,#+0
   \   00000018   2E0100EF           SWI      +302
   \   0000001C   20002DE9           PUSH     {R5}
   \   00000020   01002DE9           PUSH     {R0}
   \   00000024   AF30A0E3           MOV      R3,#+175
   \   00000028   8320A0E3           MOV      R2,#+131
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   0000A0E3           MOV      R0,#+0
   \   00000034   01002DE9           PUSH     {R0}
   \   00000038   01002DE9           PUSH     {R0}
   \   0000003C   01002DE9           PUSH     {R0}
   \   00000040   500100EF           SWI      +336
    188            wsprintf(data->ws1,"XTask v1.1\n(C)2006 by Rst7/CBSIE\n\n%t%d",
    189          	   "Сейчас диалогов: ",
    190          	   GetNumberOfDialogs());
   \   00000044   ........           BL       GetNumberOfDialogs
   \   00000048   00229FE5           LDR      R2,??method0_0   ;; `?<Constant "\\321\\345\\351\\367\\340\\361 \\344\\350\\`
   \   0000004C   00129FE5           LDR      R1,??method0_0+0x4  ;; `?<Constant "XTask v1.1\\n(C)2006 by...">`
   \   00000050   0030A0E1           MOV      R3,R0
   \   00000054   340094E5           LDR      R0,[R4, #+52]
   \   00000058   240100EF           SWI      +292
    191            DrawString(data->ws1,3,3,128,51,11,0,GetPaletteAdrByColorIndex(0),GetPaletteAdrByColorIndex(23));
   \   0000005C   1700A0E3           MOV      R0,#+23
   \   00000060   2E0100EF           SWI      +302
   \   00000064   0050A0E1           MOV      R5,R0
   \   00000068   0000A0E3           MOV      R0,#+0
   \   0000006C   2E0100EF           SWI      +302
   \   00000070   20002DE9           PUSH     {R5}
   \   00000074   01002DE9           PUSH     {R0}
   \   00000078   8030A0E3           MOV      R3,#+128
   \   0000007C   0320A0E3           MOV      R2,#+3
   \   00000080   0210A0E1           MOV      R1,R2
   \   00000084   0000A0E3           MOV      R0,#+0
   \   00000088   01002DE9           PUSH     {R0}
   \   0000008C   0B00A0E3           MOV      R0,#+11
   \   00000090   01002DE9           PUSH     {R0}
   \   00000094   3300A0E3           MOV      R0,#+51
   \   00000098   01002DE9           PUSH     {R0}
   \   0000009C   340094E5           LDR      R0,[R4, #+52]
   \   000000A0   4C0100EF           SWI      +332
    192          
    193            nl=nltop;
   \   000000A4   ........           LDR      R0,??DataTable12  ;; nltop
   \   000000A8   28D08DE2           ADD      SP,SP,#+40
   \   000000AC   001090E5           LDR      R1,[R0, #+0]
    194            i=0;
   \   000000B0   0020A0E3           MOV      R2,#+0
   \   000000B4   010000EA           B        ??method0_1
    195            while(nl)
    196            {
    197              i++;
    198              nl=nl->next;
   \                     ??method0_2:
   \   000000B8   001091E5           LDR      R1,[R1, #+0]
   \   000000BC   012082E2           ADD      R2,R2,#+1
    199            }
   \                     ??method0_1:
   \   000000C0   000051E3           CMP      R1,#+0
   \   000000C4   FBFFFF1A           BNE      ??method0_2
    200            if (i)
   \   000000C8   ........           LDR      R1,??DataTable19  ;; cursor
   \   000000CC   000052E3           CMP      R2,#+0
   \   000000D0   003091E5           LDR      R3,[R1, #+0]
   \   000000D4   0300000A           BEQ      ??method0_3
    201            {
    202              if (cursor>=i) cursor=i-1;
   \   000000D8   020053E1           CMP      R3,R2
   \   000000DC   020000BA           BLT      ??method0_4
   \   000000E0   013042E2           SUB      R3,R2,#+1
   \   000000E4   000000EA           B        ??method0_4
    203            }
    204            else cursor=0;
   \                     ??method0_3:
   \   000000E8   0030A0E3           MOV      R3,#+0
   \                     ??method0_4:
   \   000000EC   003081E5           STR      R3,[R1, #+0]
    205            nl=nltop;
   \   000000F0   005090E5           LDR      R5,[R0, #+0]
    206            if (cursor<2)
   \   000000F4   020053E3           CMP      R3,#+2
    207            {
    208              pos=0;
    209              vcur=cursor;
   \   000000F8   0360A0B1           MOVLT    R6,R3
   \   000000FC   060000BA           BLT      ??method0_5
    210            }
    211            else
    212            {
    213              pos=cursor-2;
   \   00000100   020053E2           SUBS     R0,R3,#+2
    214              vcur=2;
   \   00000104   0260A0E3           MOV      R6,#+2
   \   00000108   020000EA           B        ??method0_6
    215            }
    216            while(pos)
    217            {
    218              if (nl)
   \                     ??method0_7:
   \   0000010C   000055E3           CMP      R5,#+0
    219              {
    220                nl=nl->next;
   \   00000110   00509515           LDRNE    R5,[R5, #+0]
    221              }
    222              pos--;
   \   00000114   010050E2           SUBS     R0,R0,#+1
    223            }
   \                     ??method0_6:
   \   00000118   FBFFFF1A           BNE      ??method0_7
    224            i=0;
   \                     ??method0_5:
   \   0000011C   0070A0E3           MOV      R7,#+0
   \   00000120   4580A0E3           MOV      R8,#+69
    225            do
    226            {
    227              if (nl)
   \                     ??method0_8:
   \   00000124   000055E3           CMP      R5,#+0
   \   00000128   2C00000A           BEQ      ??method0_9
    228              {
    229                if (nl->name)
   \   0000012C   040095E5           LDR      R0,[R5, #+4]
   \   00000130   000050E3           CMP      R0,#+0
   \   00000134   2800000A           BEQ      ??method0_10
    230                {
    231          	if (i==vcur)
   \   00000138   060057E1           CMP      R7,R6
   \   0000013C   1300001A           BNE      ??method0_11
    232          	{
    233          	  selcsm=nl->p;
   \   00000140   ........           LDR      R0,??DataTable20  ;; selcsm
   \   00000144   081095E5           LDR      R1,[R5, #+8]
   \   00000148   001080E5           STR      R1,[R0, #+0]
    234          	  DrawRoundedFrame(3,55+14*i,128,58+11+14*i,0,0,0,
    235          			GetPaletteAdrByColorIndex(0),
    236          			GetPaletteAdrByColorIndex(3));
   \   0000014C   0300A0E3           MOV      R0,#+3
   \   00000150   2E0100EF           SWI      +302
   \   00000154   0090A0E1           MOV      R9,R0
   \   00000158   0000A0E3           MOV      R0,#+0
   \   0000015C   2E0100EF           SWI      +302
   \   00000160   00022DE9           PUSH     {R9}
   \   00000164   01002DE9           PUSH     {R0}
   \   00000168   0830A0E1           MOV      R3,R8
   \   0000016C   8020A0E3           MOV      R2,#+128
   \   00000170   0E1048E2           SUB      R1,R8,#+14
   \   00000174   0000A0E3           MOV      R0,#+0
   \   00000178   01002DE9           PUSH     {R0}
   \   0000017C   01002DE9           PUSH     {R0}
   \   00000180   01002DE9           PUSH     {R0}
   \   00000184   0300A0E3           MOV      R0,#+3
   \   00000188   500100EF           SWI      +336
   \   0000018C   14D08DE2           ADD      SP,SP,#+20
    237          	}
    238          	DrawString(nl->name,5,57+14*i,126,57+11+14*i,11,0x80,GetPaletteAdrByColorIndex(0),GetPaletteAdrByColorIndex(23));
   \                     ??method0_11:
   \   00000190   1700A0E3           MOV      R0,#+23
   \   00000194   2E0100EF           SWI      +302
   \   00000198   0090A0E1           MOV      R9,R0
   \   0000019C   0000A0E3           MOV      R0,#+0
   \   000001A0   2E0100EF           SWI      +302
   \   000001A4   00022DE9           PUSH     {R9}
   \   000001A8   01002DE9           PUSH     {R0}
   \   000001AC   7E30A0E3           MOV      R3,#+126
   \   000001B0   0C2048E2           SUB      R2,R8,#+12
   \   000001B4   0510A0E3           MOV      R1,#+5
   \   000001B8   8000A0E3           MOV      R0,#+128
   \   000001BC   01002DE9           PUSH     {R0}
   \   000001C0   0B00A0E3           MOV      R0,#+11
   \   000001C4   01002DE9           PUSH     {R0}
   \   000001C8   010048E2           SUB      R0,R8,#+1
   \   000001CC   01002DE9           PUSH     {R0}
   \   000001D0   040095E5           LDR      R0,[R5, #+4]
   \   000001D4   4C0100EF           SWI      +332
   \   000001D8   14D08DE2           ADD      SP,SP,#+20
    239                }
    240                nl=nl->next;
   \                     ??method0_10:
   \   000001DC   005095E5           LDR      R5,[R5, #+0]
    241              }
    242              i++;
   \                     ??method0_9:
   \   000001E0   017087E2           ADD      R7,R7,#+1
    243            }
    244            while(i<5);
   \   000001E4   0E8088E2           ADD      R8,R8,#+14
   \   000001E8   050057E3           CMP      R7,#+5
   \   000001EC   CCFFFFBA           BLT      ??method0_8
    245          
    246            wsprintf(data->ws2,percent_t," Idle           Назад");
   \   000001F0   380094E5           LDR      R0,[R4, #+56]
   \   000001F4   5C209FE5           LDR      R2,??method0_0+0x8  ;; `?<Constant " Idle           \\315\\340\\347\\340\\3`
   \   000001F8   ........           LDR      R1,??DataTable15  ;; percent_t
   \   000001FC   240100EF           SWI      +292
    247            DrawString(data->ws2,3,157,128,172,5,2,GetPaletteAdrByColorIndex(0),GetPaletteAdrByColorIndex(23));
   \   00000200   1700A0E3           MOV      R0,#+23
   \   00000204   2E0100EF           SWI      +302
   \   00000208   0050A0E1           MOV      R5,R0
   \   0000020C   0000A0E3           MOV      R0,#+0
   \   00000210   2E0100EF           SWI      +302
   \   00000214   20002DE9           PUSH     {R5}
   \   00000218   01002DE9           PUSH     {R0}
   \   0000021C   8030A0E3           MOV      R3,#+128
   \   00000220   9D20A0E3           MOV      R2,#+157
   \   00000224   0310A0E3           MOV      R1,#+3
   \   00000228   0200A0E3           MOV      R0,#+2
   \   0000022C   01002DE9           PUSH     {R0}
   \   00000230   0500A0E3           MOV      R0,#+5
   \   00000234   01002DE9           PUSH     {R0}
   \   00000238   AC00A0E3           MOV      R0,#+172
   \   0000023C   01002DE9           PUSH     {R0}
   \   00000240   380094E5           LDR      R0,[R4, #+56]
   \   00000244   4C0100EF           SWI      +332
    248          }
   \   00000248   14D08DE2           ADD      SP,SP,#+20
   \   0000024C   F083BDE8           POP      {R4-R9,PC}       ;; return
   \                     ??method0_0:
   \   00000250   ........           DC32     `?<Constant "\\321\\345\\351\\367\\340\\361 \\344\\350\\`
   \   00000254   ........           DC32     `?<Constant "XTask v1.1\\n(C)2006 by...">`
   \   00000258   ........           DC32     `?<Constant " Idle           \\315\\340\\347\\340\\3`
    249          

   \                                 In segment CODE, align 4, keep-with-next
    250          void method1(MAIN_GUI *data, void *(*malloc_adr)(int))
    251          {
   \                     method1:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040A0E1           MOV      R4,R0
    252            int f;
    253            int sz=0;
    254            unsigned int ul;
    255            data->ws1=AllocWS(256);
   \   0000000C   400FA0E3           MOV      R0,#+256
   \   00000010   250100EF           SWI      +293
   \   00000014   340084E5           STR      R0,[R4, #+52]
    256            data->ws2=AllocWS(256);
   \   00000018   400FA0E3           MOV      R0,#+256
   \   0000001C   250100EF           SWI      +293
   \   00000020   380084E5           STR      R0,[R4, #+56]
    257            if ((f=fopen("4:\\ZBin\\etc\\CSMlist.txt",A_ReadOnly+A_BIN,0,&ul))!=-1)
   \   00000024   6C009FE5           LDR      R0,??method1_0   ;; `?<Constant "4:\\\\ZBin\\\\etc\\\\CSMlist.txt">`
   \   00000028   0D30A0E1           MOV      R3,SP
   \   0000002C   0020A0E3           MOV      R2,#+0
   \   00000030   801CA0E3           MOV      R1,#+32768
   \   00000034   0A0000EF           SWI      +10
   \   00000038   0050A0E1           MOV      R5,R0
   \   0000003C   0060A0E3           MOV      R6,#+0
   \   00000040   010075E3           CMN      R5,#+1
   \   00000044   0B00000A           BEQ      ??method1_1
    258            {
    259              sz=fread(f,csm_text,32767,&ul);
   \   00000048   ........           LDR      R7,??DataTable16  ;; csm_text
   \   0000004C   0D30A0E1           MOV      R3,SP
   \   00000050   FF20A0E3           MOV      R2,#+255
   \   00000054   7F2C82E3           ORR      R2,R2,#0x7F00
   \   00000058   0710A0E1           MOV      R1,R7
   \   0000005C   0B0000EF           SWI      +11
   \   00000060   0080A0E1           MOV      R8,R0
    260              fclose(f,&ul);
   \   00000064   0D10A0E1           MOV      R1,SP
   \   00000068   0500A0E1           MOV      R0,R5
   \   0000006C   0D0000EF           SWI      +13
    261            }
    262            if (sz>0) csm_text[sz]=0;
   \   00000070   010058E3           CMP      R8,#+1
   \   00000074   0760C8A7           STRBGE   R6,[R8, +R7]
    263            cursor=1; //На следующий
   \                     ??method1_1:
   \   00000078   ........           LDR      R1,??DataTable19  ;; cursor
   \   0000007C   0100A0E3           MOV      R0,#+1
   \   00000080   000081E5           STR      R0,[R1, #+0]
    264            selcsm=0;
   \   00000084   ........           LDR      R1,??DataTable20  ;; selcsm
   \   00000088   006081E5           STR      R6,[R1, #+0]
    265            data->gui.state=1;
   \   0000008C   0C00C4E5           STRB     R0,[R4, #+12]
    266          }
   \   00000090   04D08DE2           ADD      SP,SP,#+4
   \   00000094   F081BDE8           POP      {R4-R8,PC}       ;; return
   \                     ??method1_0:
   \   00000098   ........           DC32     `?<Constant "4:\\\\ZBin\\\\etc\\\\CSMlist.txt">`
    267          

   \                                 In segment CODE, align 4, keep-with-next
    268          void method2(MAIN_GUI *data, void (*mfree_adr)(void *))
    269          {
   \                     method2:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    270            ClearNL();
   \   00000008   ........           BL       ClearNL
    271            FreeWS(data->ws1);
   \   0000000C   340094E5           LDR      R0,[R4, #+52]
   \   00000010   290100EF           SWI      +297
    272            FreeWS(data->ws2);
   \   00000014   380094E5           LDR      R0,[R4, #+56]
   \   00000018   290100EF           SWI      +297
    273            data->gui.state=0;
   \   0000001C   0000A0E3           MOV      R0,#+0
   \   00000020   0C00C4E5           STRB     R0,[R4, #+12]
   \   00000024   1080BDE8           POP      {R4,PC}          ;; return
    274          }
    275          

   \                                 In segment CODE, align 4, keep-with-next
    276          void method3(MAIN_GUI *data, void *(*malloc_adr)(int), void (*mfree_adr)(void *))
    277          {
    278            data->gui.state=2;
   \                     method3:
   \   00000000   0210A0E3           MOV      R1,#+2
   \   00000004   0C10C0E5           STRB     R1,[R0, #+12]
   \   00000008   1EFF2FE1           BX       LR               ;; return
    279          }
    280          

   \                                 In segment CODE, align 4, keep-with-next
    281          void method4(MAIN_GUI *data, void (*mfree_adr)(void *))
    282          {
    283            if (data->gui.state!=2) return;
   \                     method4:
   \   00000000   0C10D0E5           LDRB     R1,[R0, #+12]
   \   00000004   020051E3           CMP      R1,#+2
    284            data->gui.state=1;
   \   00000008   0110A003           MOVEQ    R1,#+1
   \   0000000C   0C10C005           STRBEQ   R1,[R0, #+12]
   \   00000010   1EFF2FE1           BX       LR               ;; return
    285          }
    286          

   \                                 In segment CODE, align 4, keep-with-next
    287          int method5(MAIN_GUI *data, GUI_MSG *msg)
    288          {
   \                     method5:
   \   00000000   00402DE9           PUSH     {LR}
    289            if (msg->gbsmsg->msg==KEY_DOWN)
   \   00000004   040091E5           LDR      R0,[R1, #+4]
   \   00000008   9320A0E3           MOV      R2,#+147
   \   0000000C   041090E5           LDR      R1,[R0, #+4]
   \   00000010   402F82E3           ORR      R2,R2,#0x100
   \   00000014   020051E1           CMP      R1,R2
   \   00000018   1B00001A           BNE      ??method5_0
    290            {
    291              switch(msg->gbsmsg->submess)
   \   0000001C   ........           LDR      R1,??DataTable19  ;; cursor
   \   00000020   080090E5           LDR      R0,[R0, #+8]
   \   00000024   002091E5           LDR      R2,[R1, #+0]
   \   00000028   010050E2           SUBS     R0,R0,#+1
   \   0000002C   0800000A           BEQ      ??method5_1
   \   00000030   030050E2           SUBS     R0,R0,#+3
   \   00000034   0C00000A           BEQ      ??method5_2
   \   00000038   160050E2           SUBS     R0,R0,#+22
   \   0000003C   0900000A           BEQ      ??method5_3
   \   00000040   210050E2           SUBS     R0,R0,#+33
   \   00000044   0A00000A           BEQ      ??method5_4
   \   00000048   010050E2           SUBS     R0,R0,#+1
   \   0000004C   0C00000A           BEQ      ??method5_5
   \   00000050   0D0000EA           B        ??method5_0
    292              {
    293              case LEFT_SOFT:
    294                selcsm=FindCSMbyID(CSM_root()->idle_id);
   \                     ??method5_1:
   \   00000054   068100EF           SWI      +33030
   \   00000058   040090E5           LDR      R0,[R0, #+4]
   \   0000005C   080100EF           SWI      +264
   \   00000060   ........           LDR      R1,??DataTable20  ;; selcsm
   \   00000064   000081E5           STR      R0,[R1, #+0]
    295              case ENTER_BUTTON:
    296                SwapCSMS();
   \                     ??method5_3:
   \   00000068   ........           BL       SwapCSMS
    297              case RIGHT_SOFT:
    298                return(1); //Происходит вызов GeneralFunc для тек. GUI -> закрытие GUI
   \                     ??method5_2:
   \   0000006C   0100A0E3           MOV      R0,#+1
   \   00000070   0080BDE8           POP      {PC}
    299              case UP_BUTTON:
    300                if (cursor) cursor--;
   \                     ??method5_4:
   \   00000074   000052E3           CMP      R2,#+0
   \   00000078   0300000A           BEQ      ??method5_0
   \   0000007C   010042E2           SUB      R0,R2,#+1
   \   00000080   000000EA           B        ??method5_6
    301                break;
    302              case DOWN_BUTTON:
    303                cursor++;
   \                     ??method5_5:
   \   00000084   010082E2           ADD      R0,R2,#+1
   \                     ??method5_6:
   \   00000088   000081E5           STR      R0,[R1, #+0]
    304                break;
    305              }
    306            }
    307            DirectRedrawGUI();
   \                     ??method5_0:
   \   0000008C   3F0100EF           SWI      +319
    308            return(0);
   \   00000090   0000A0E3           MOV      R0,#+0
   \   00000094   0080BDE8           POP      {PC}             ;; return
    309          }
    310          

   \                                 In segment CODE, align 4, keep-with-next
    311          void method7(MAIN_GUI *data, void (*mfree_adr)(void *))
    312          {
    313            mfree_adr(data);
   \                     method7:
   \   00000000   01F0A0E1           MOV      PC,R1            ;; tailcall
    314          }
    315          

   \                                 In segment CODE, align 4, keep-with-next
    316          int method8(void){return(0);}
   \                     method8:
   \   00000000   0000A0E3           MOV      R0,#+0
   \   00000004   1EFF2FE1           BX       LR               ;; return
    317          

   \                                 In segment CODE, align 4, keep-with-next
    318          int method9(void){return(0);}
   \                     method9:
   \   00000000   0000A0E3           MOV      R0,#+0
   \   00000004   1EFF2FE1           BX       LR               ;; return
    319          

   \                                 In segment DATA_C, align 4, align-sorted
    320          const void * const gui_methods[11]={
   \                     gui_methods:
   \   00000000   ............       DC32 method0, method1, method2, method3, method4, method5, 0H, method7
   \              ............
   \              ............
   \              ............
   \              00000000....
   \              ....        
   \   00000020   ............       DC32 method8, method9, 0H
   \              ....00000000
    321            (void *)method0,	//Redraw
    322            (void *)method1,	//Create
    323            (void *)method2,	//Close
    324            (void *)method3,	//Focus
    325            (void *)method4,	//Unfocus
    326            (void *)method5,	//OnKey
    327            0,
    328            (void *)method7,	//Destroy
    329            (void *)method8,
    330            (void *)method9,
    331            0
    332          };
    333          

   \                                 In segment DATA_C, align 4, align-sorted
    334          const RECT Canvas={0,0,131,175};
   \                     Canvas:
   \   00000000   000000008300       DC16 0, 0, 131, 175
   \              AF00        
    335          

   \                                 In segment CODE, align 4, keep-with-next
    336          void maincsm_oncreate(CSM_RAM *data)
    337          {
   \                     maincsm_oncreate:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    338            MAIN_GUI *main_gui=malloc(sizeof(MAIN_GUI));
   \   00000008   3C00A0E3           MOV      R0,#+60
   \   0000000C   140000EF           SWI      +20
   \   00000010   0050A0E1           MOV      R5,R0
    339            MAIN_CSM*csm=(MAIN_CSM*)data;
    340            zeromem(main_gui,sizeof(MAIN_GUI));
   \   00000014   3C10A0E3           MOV      R1,#+60
   \   00000018   1D0100EF           SWI      +285
    341            main_gui->gui.canvas=(void *)(&Canvas);
   \   0000001C   34009FE5           LDR      R0,??maincsm_oncreate_0  ;; Canvas
   \   00000020   000085E5           STR      R0,[R5, #+0]
    342            main_gui->gui.flag30=2;
   \   00000024   0200A0E3           MOV      R0,#+2
   \   00000028   300085E5           STR      R0,[R5, #+48]
    343            main_gui->gui.methods=(void *)gui_methods;
   \   0000002C   28009FE5           LDR      R0,??maincsm_oncreate_0+0x4  ;; gui_methods
   \   00000030   040085E5           STR      R0,[R5, #+4]
    344            main_gui->gui.item_ll.data_mfree=(void (*)(void *))mfree_adr();
   \   00000034   158000EF           SWI      +32789
   \   00000038   200085E5           STR      R0,[R5, #+32]
    345            csm->csm.state=0;
   \   0000003C   0000A0E3           MOV      R0,#+0
   \   00000040   100084E5           STR      R0,[R4, #+16]
    346            csm->csm.unk1=0;
   \   00000044   140084E5           STR      R0,[R4, #+20]
    347            csm->gui_id=CreateGUI(main_gui);
   \   00000048   0500A0E1           MOV      R0,R5
   \   0000004C   370100EF           SWI      +311
   \   00000050   280084E5           STR      R0,[R4, #+40]
   \   00000054   3080BDE8           POP      {R4,R5,PC}       ;; return
   \                     ??maincsm_oncreate_0:
   \   00000058   ........           DC32     Canvas
   \   0000005C   ........           DC32     gui_methods
    348          }
    349          

   \                                 In segment CODE, align 4, keep-with-next
    350          void maincsm_onclose(CSM_RAM *csm)
    351          {
    352            //  extern void *ELF_BEGIN;
    353            //  ((void (*)(void *))(mfree_adr()))(&ELF_BEGIN);
    354            mode=0;
   \                     maincsm_onclose:
   \   00000000   ........           LDR      R0,??DataTable24  ;; mode
   \   00000004   0010A0E3           MOV      R1,#+0
   \   00000008   001080E5           STR      R1,[R0, #+0]
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    355          }
    356          

   \                                 In segment CODE, align 4, keep-with-next
    357          int maincsm_onmessage(CSM_RAM *data, GBS_MSG *msg)
    358          {
    359            MAIN_CSM *csm=(MAIN_CSM*)data;
    360            if ((msg->msg==MSG_GUI_DESTROYED)&&((int)msg->data0==csm->gui_id))
   \                     maincsm_onmessage:
   \   00000000   042091E5           LDR      R2,[R1, #+4]
   \   00000004   0E30A0E3           MOV      R3,#+14
   \   00000008   643C83E3           ORR      R3,R3,#0x6400
   \   0000000C   030052E1           CMP      R2,R3
   \   00000010   0400001A           BNE      ??maincsm_onmessage_0
   \   00000014   0C1091E5           LDR      R1,[R1, #+12]
   \   00000018   282090E5           LDR      R2,[R0, #+40]
   \   0000001C   020051E1           CMP      R1,R2
    361            {
    362              csm->csm.state=-3;
   \   00000020   0210E003           MVNEQ    R1,#+2
   \   00000024   10108005           STREQ    R1,[R0, #+16]
    363            }
    364            return(1);
   \                     ??maincsm_onmessage_0:
   \   00000028   0100A0E3           MOV      R0,#+1
   \   0000002C   1EFF2FE1           BX       LR               ;; return
    365          }
    366          

   \                                 In segment DATA_C, align 4, align-sorted
    367          const int minus11=-11;
   \                     minus11:
   \   00000000   F5FFFFFF           DC32 -11
    368          

   \                                 In segment DATA_C, align 4, align-sorted
    369          const CSM_DESC maincsm=
   \                     maincsm:
   \   00000000   ............       DC32 maincsm_onmessage, maincsm_oncreate, 0, 0, 0, 0, maincsm_onclose
   \              ....00000000
   \              000000000000
   \              000000000000
   \              ........    
   \   0000001C   2C0000000100       DC32 44, 1, minus11
   \              0000........
    370          {
    371            maincsm_onmessage,
    372            maincsm_oncreate,
    373            0,
    374            0,
    375            0,
    376            0,
    377            maincsm_onclose,
    378            sizeof(MAIN_CSM),
    379            1,
    380            &minus11
    381          };
    382          

   \                                 In segment CODE, align 4, keep-with-next
    383          void do_gui(void)
    384          {
    385            char dummy[sizeof(MAIN_CSM)];
    386            my_csm_id=CreateCSM(&maincsm,dummy,0);
   \                     do_gui:
   \   00000000   ........           LDR      R0,??DataTable22  ;; maincsm
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   2CD04DE2           SUB      SP,SP,#+44
   \   0000000C   0020A0E3           MOV      R2,#+0
   \   00000010   0D10A0E1           MOV      R1,SP
   \   00000014   070100EF           SWI      +263
   \   00000018   ........           LDR      R1,??DataTable23  ;; my_csm_id
   \   0000001C   000081E5           STR      R0,[R1, #+0]
    387            mode=-1;
   \   00000020   ........           LDR      R0,??DataTable24  ;; mode
   \   00000024   0010E0E3           MVN      R1,#+0
   \   00000028   001080E5           STR      R1,[R0, #+0]
    388          }
   \   0000002C   2CD08DE2           ADD      SP,SP,#+44
   \   00000030   0080BDE8           POP      {PC}             ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   ........           DC32     nlbot

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   ........           DC32     under_idle

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   ........           DC32     nltop

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   ........           DC32     percent_t

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   ........           DC32     csm_text

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   ........           DC32     cursor

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   ........           DC32     selcsm

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   ........           DC32     maincsm

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   ........           DC32     my_csm_id

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   ........           DC32     mode

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "%08X ">`:
   \   00000000   253038582000       DC8 "%08X "
   \   00000006   0000               DC8 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "Unknown %08X!">`:
   \   00000000   556E6B6E6F77       DC8 "Unknown %08X!"
   \              6E2025303858
   \              2100        
   \   0000000E   0000               DC8 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "IDLE Screen">`:
   \   00000000   49444C452053       DC8 "IDLE Screen"
   \              637265656E00

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "!SKIP!">`:
   \   00000000   21534B495021       DC8 "!SKIP!"
   \              00          
   \   00000007   00                 DC8 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "XTask v1.1\\n(C)2006 by...">`:
   \   00000000   585461736B20       DC8 "XTask v1.1\012(C)2006 by Rst7/CBSIE\012\012%t%d"
   \              76312E310A28
   \              432932303036
   \              206279205273
   \              74372F434253
   \              49450A0A2574
   \              256400      
   \   00000027   00                 DC8 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "\\321\\345\\351\\367\\340\\361 \\344\\350\\`:
   \   00000000   D1E5E9F7E0F1       DC8 "\321\345\351\367\340\361 \344\350\340\353\356\343\356\342: "
   \              20E4E8E0EBEE
   \              E3EEE23A2000
   \   00000012   0000               DC8 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant " Idle           \\315\\340\\347\\340\\3`:
   \   00000000   2049646C6520       DC8 " Idle           \315\340\347\340\344"
   \              202020202020
   \              20202020CDE0
   \              E7E0E400    
   \   00000016   0000               DC8 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "4:\\\\ZBin\\\\etc\\\\CSMlist.txt">`:
   \   00000000   343A5C5A4269       DC8 "4:\\ZBin\\etc\\CSMlist.txt"
   \              6E5C6574635C
   \              43534D6C6973
   \              742E74787400

   Maximum stack usage in bytes:

     Function           CSTACK
     --------           ------
     AddNL                 12
     ClearNL               12
     GetNumberOfDialogs    28
     SwapCSMS              52
     do_gui                48
     find_name             52
     maincsm_onclose        0
     maincsm_oncreate      12
     maincsm_onmessage      0
     method0               68
     method1               28
     method2                8
     method3                0
     method4                0
     method5                4
     method7                4
     method8                0
     method9                0


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     my_csm_id                          4
     cursor                             4
     selcsm                             4
     nltop                              4
     nlbot                              4
     csm_text                       32768
     percent_t                          3
     ClearNL                           80
     AddNL                             76
     find_name                         96
     u                                 40
     GetNumberOfDialogs               268
     SwapCSMS                         256
     method0                          604
     method1                          156
     method2                           40
     method3                           12
     method4                           20
     method5                          152
     method7                            4
     method8                            8
     method9                            8
     gui_methods                       44
     Canvas                             8
     maincsm_oncreate                  96
     maincsm_onclose                   16
     maincsm_onmessage                 48
     minus11                            4
     maincsm                           40
     do_gui                            52
     ??DataTable3                       4
     ??DataTable10                      4
     ??DataTable12                      4
     ??DataTable15                      4
     ??DataTable16                      4
     ??DataTable19                      4
     ??DataTable20                      4
     ??DataTable22                      4
     ??DataTable23                      4
     ??DataTable24                      4
     ?<Constant "%08X ">                8
     ?<Constant "Unknown %08X!">       16
     ?<Constant "IDLE Screen">         12
     ?<Constant "!SKIP!">               8
     ?<Constant "XTask v1.1\n(C)2006 by...">
                                       40
     ?<Constant "\321\345\351\367\340\361 \344\350\
                                       20
     ?<Constant " Idle           \315\340\347\340\3
                                       24
     ?<Constant "4:\\ZBin\\etc\\CSMlist.txt">
                                       24
      Others                           84

 
  2 104 bytes in segment CODE
    251 bytes in segment DATA_C
 32 828 bytes in segment DATA_Z
     12 bytes in segment INITTAB
 
  2 032 bytes of CODE  memory (+ 84 bytes shared)
    251 bytes of CONST memory
 32 828 bytes of DATA  memory

Errors: none
Warnings: none
