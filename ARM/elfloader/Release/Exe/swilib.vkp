;ELFpack v1.7 (C)2006 by Rst7/CBSIE, BoBa
;Release 13.10.2006
;Также бибилиотека для патчей
;
;+Загрузка всех .elf-файлов из каталога 4:\ZBin\Daemons
;
;+Загрузка необходимых .elf файлов при выборе файла с произвольным расширением
; по файлу 4:\ZBin\etc\extension.cfg. Формат файла:
; ...
; расширение_без_точки:полный_путь_и_имя_elf_файла<CR><LF>
; ...
; Последняя строка в файле - универсальное расширение, рекоммендуется прописать
; туда строку "*:4:\ZBin\TED\Ted.elf"
;
;+Исправлен HELPER_PROC (заменен cepid с 4338 на 4339)
;
;+Перенесены в библиотеку функции SUBPROC и REDRAW - находятся в HELPER
;
;+Удаление процесса HELPER_PROC при закрытии IDLE_CSM
;
;+Для упрощения формирования структуры каталогов разархивируйте в корень MMC архив
; ММС.zip с сохранением путей.
;
;+Вынесены адреса возврата в отдельный сегмент (RET_ADRS) для упрощения портирования
;
;+Ублажены юзеры МП - перенесен GetCPULoad
;
;+ESI теперь поддерживает украинские символы
;
;+Поддержка эльфов SVv4, генерируемых LD (respect DeathSoft)
;
;+Ретрансляция сообщений из HELPER_PROC в MMI

+0074000
#pragma enable old_equal_ff
;Generated by PATSearchNT by BoBa v0.4
0000: 0xA00020F0 ; 000: __arm void loopback0();
0004: 0xA00020F0 ; 001: __arm void loopback1();
0008: 0xA00020F0 ; 002: __arm void loopback2();
000C: 0xA00020F0 ; 003: __arm void loopback3();
0010: 0xA00020F0 ; 004: __arm void loopback4();
0018: 0xA01AA3FC ; 006: __arm int GetAkku(int param1,int param2);
0020: 0xA01B4958 ; 008: __arm long SetIllumination(unsigned char dev,unsigned long param1,unsigned short bright,unsigned long delay);
0028: 0xA025127C ; 00A: __arm int fopen(const char * cFileName, unsigned int iFileFlags, unsigned int iFileMode, unsigned int *ErrorNumber);
002C: 0xA025133C ; 00B: __arm int fread(int FileHandler, void *cBuffer, int iByteCount, unsigned int *ErrorNumber);
0030: 0xA025146C ; 00C: __arm unsigned int fwrite(int FileHandler, char * cBuffer, int iByteCount, unsigned int *ErrorNumber);
0034: 0xA02511D0 ; 00D: __arm void fclose(int FileHandler, unsigned int *ErrorNumber);
003C: 0xA0251230 ; 00F: __arm unsigned int lseek(int FileHandler, unsigned int offset, unsigned int origin, unsigned int *ErrorNumber, unsigned int *ErrorNumber2);
0040: 0xA0250E74 ; 010: __arm int mkdir(const char * cFileName, unsigned int *ErrorNumber);
0048: 0xA0250CD4 ; 012: __arm int GetFileAttrib(const char *cFileName, unsigned char *cAttribute, unsigned int *ErrorNumber);
004C: 0xA0250FC8 ; 013: __arm int SetFileAttrib(const char *cFileName, unsigned char cAttribute, unsigned int *ErrorNumber);
0050: 0xA0094B5C ; 014: __arm void *malloc(unsigned int size);
0054: 0xA0094948 ; 015: __arm void mfree(void *);
0058: 0xA0FC4385 ; 016: __thumb int sprintf(char *buf, char *str, ...);
005C: 0xA0FC5DF1 ; 017: __thumb char * strcat (char *,const char *);
0060: 0xA0FC5E11 ; 018: __thumb char * strchr (const char *,int);
0064: 0xA0FC5E34 ; 019: __arm int  strcmp (const char *,const char *);
0068: 0xA0FC5ED1 ; 01A: __thumb char * strcpy (char *dest,const char *source);
006C: 0xA0FC5F51 ; 01B: __thumb unsigned int strlen(char *);
0070: 0xA01F5BCD ; 01C: __thumb void  wsAppendChar (void *WSHDR,int wchar);
008C: 0xA029B7E1 ; 023: __thumb void DrawImg(unsigned char x, unsigned char y, short picture);
0094: 0xA029ACDB ; 025: __thumb void DrawCanvas(void *data, int x1, int y1, int x2, int y2, int flag_one);
00A8: 0xA01E4190 ; 02A: __arm int *GetEELiteBlockAddress(short blocknum);
00C8: 0xA0280D20 ; 032: __arm void PlaySound(long param1, long param2, long param3, long tone, long param5);
00F0: 0xA025137C ; 03C: __arm int setfilesize(int FileHandler, unsigned int iNewFileSize, unsigned int *ErrorNumber);
010C: 0xA09007BB ; 043: __thumb int IsUnlocked(void);
0134: 0xA0093278 ; 04D: __arm void GBS_StartTimerProc(void *htimer, long ms, void ptr());
0170: 0xA01CF82C ; 05C: __arm char GetCPUClock();
0174: 0xA0331C37 ; 05D: __thumb char GetCPULoad();
017C: 0xA0094BE8 ; 05F: __arm int GetFreeRamAvail();
01AC: 0xA0250D4C ; 06B: __arm int FindFirstFile (void *DIRENTRY,char *mask,int *ErrorNumber);
01B0: 0xA0250DCC ; 06C: __arm int FindNextFile (void *DIRENTRY,int *ErrorNumber);
01B4: 0xA0250C94 ; 06D: __arm int FindClose (void *DIRENTRY,int *ErrorNumber);
01BC: 0xA0951CA8 ; 06F: __arm void RefreshGPRSTraffic();
01C0: 0xA0951CD8 ; 070: __arm int *GetGPRSTrafficPointer();
01F0: 0xA01AF22B ; 07C: __thumb unsigned SetVibration(unsigned int power);
0200: 0xA05E212D ; 080: __thumb void ShowCallList(int list, int zero);
0210: 0xA0251040 ; 084: __arm int GetFileStats(const char *cFileName, void * StatBuffer, unsigned int *errornumber);
0228: 0xA0250C24 ; 08A: __arm int GetFreeFlexSpace(int DriveNum, unsigned int *ErrorNumber);
022C: 0xA02514D8 ; 08B: __arm int GetTotalFlexSpace(int DriveNum, unsigned int *ErrorNumber);
0230: 0xA04D48A9 ; 08C: __thumb void RegExplorerExt(REGEXPLEXT *);
0238: 0xA0250EDC ; 08E: __arm int fmove(const char * SourceFileName, const char * DestFileName, unsigned int *ErrorNumber);
023C: 0xA0250F60 ; 08F: __arm int rmdir(const char * cDirectory, unsigned int *ErrorNumber);
0240: 0xA02513F4 ; 090: __arm int truncate(int FileHandler, int length, int *errornumber);
0244: 0xA0250E0C ; 091: __arm int isdir(const char * cDirectory, unsigned int *ErrorNumber);
028C: 0xA02519BC ; 0A3: __arm void ws_2str(WSHDR *ws, char *str, unsigned int size);
0298: 0xA0951C80 ; 0A6: __arm void ResetGPRSTraffic();
02AC: 0xA00020F0 ; 0AB: __arm void loopback171();
02D0: 0xA08FCD77 ; 0B4: __thumb void GetDateTime(TDate *, TTime *);
02D4: 0xA026CAA3 ; 0B5: __thumb char GetWeek(TDate*);
02D8: 0xA0288F27 ; 0B6: __thumb char GetProfile();
02DC: 0xA0288F87 ; 0B7: __thumb char SetProfile(char);
02E0: 0xA0FC5784 ; 0B8: __arm int dwMODdw(int denom,int number);
029C: 0xA0D42E88 ; 0A7: __arm char IsGPRSEnabled();
02A0: 0xA0D09EFD ; 0A8: __thumb char IsGPRSConnected();
02A4: 0xA0900FA3 ; 0A9: __thumb void KbdLock();
02E4: 0xA0900A87 ; 0B9: __thumb void KbdUnlock();
02E8: 0xA0094B68 ; 0BA: __arm void *realloc(void *ptr, int size);
02EC: 0xA0FC576C ; 0BB: __arm void *memset(void *s, int c, int n);
02F0: 0xA0FC585C ; 0BC: __arm int divide(int divisor, int dividend);
02F4: 0xA0FC5920 ; 0BD: __arm int DivBy10(int divident);
0318: 0xA01A6B40 ; 0C6: __arm char GetAkkuCapacity();
0400: 0xA0092A94 ; 100: __arm void GBS_SendMessage(int cepid_to, int msg, ...); //int submess, void *data1, void *data2
0404: 0xA0091950 ; 101: __arm int GBS_ReciveMessage(GBS_MSG *);
0408: 0xA009209C ; 102: __arm void GBS_AcceptMessage(void);
040C: 0xA0091DA4 ; 103: __arm void GBS_ClearMessage(void);
0410: 0xA0091F88 ; 104: __arm void GBS_PendMessage(GBS_MSG *);
0414: 0xA0092F40 ; 105: __arm void CreateGBSproc(int cepid, const char *name, void (*onMsg)(void), int prio, int unk_zero);
0418: 0xA8DB99B0 ; 8106: __arm CSMROOT *CSM_root();
041C: 0xA096FA4B ; 107: __thumb int CreateCSM(const CSM_DESC*,void *,int);
0420: 0xA096FA5D ; 108: __thumb CSM_RAM * FindCSMbyID (void *csm_q,int id);
0424: 0xA096FB19 ; 109: __thumb void DoIDLE(void);
;0428: 0x00000000 ; 10A: __unknown void *GetConfig(unsigned int id); //BoBaPack
042C: 0xA0030000 ; 810B: __arm void *GetMinAdrScan(); //BoBaPack
0430: 0xA0040000 ; 810C: __arm void *GetMaxAdrScan(); //BoBaPack
0434: 0x00000000 ; 810D: __unknown unsigned short *GetCI();
;0438: 0x00000000 ; 10E: __unknown void Vibration(unsigned int power, unsigned int duration); //BoBaPack
043C: 0xA0299E1D ; 10F: __thumb void freeUSSD();
0440: 0xA026DEB9 ; 110: __thumb char *wstrcopy(char *dst, char *src);
0444: 0xA0299E59 ; 111: __thumb char GetTypeUSSD();
0448: 0xA0299E69 ; 112: __thumb unsigned int SetUSSD(StructUSSDStr *);
044C: 0xA0FC5F21 ; 113: __thumb char * strpbrk (const char *s1,const char *s2);
0450: 0xA0FC5F9D ; 114: __thumb char * strncat (char *dest,const char *substr,int maxSubLen);
0454: 0xA0FC5FCD ; 115: __thumb int  strncmp (const char *s1,const char *s2,int n);
0458: 0xA0FC601D ; 116: __thumb int  strncpy (char *dest,const char *source,int maxlen);
045C: 0xA0FC6099 ; 117: __thumb char * strrchr (const char *s,int c);
0460: 0xA0FC60B1 ; 118: __thumb char * strstr (const char *s1,const char *s2);
0464: 0xA0FC60D9 ; 119: __thumb int  strtol (const char *nptr,char **endptr,int base);
0468: 0xA0FC6155 ; 11A: __thumb int  strtoul (const char *nptr,char **endptr,int base);
046C: 0xA0FC4331 ; 11B: __thumb int snprintf (char *,int n,const char *format,...);
0470: 0xA0018941 ; 11C: __thumb int  memcmp (void *m1,void *m2,int n);
0474: 0xA0FC556C ; 11D: __arm void  zeromem (void *dest,int n);
0478: 0xA000B228 ; 11E: __arm void * memcpy (void *dest,const void *source,int cnt);
047C: 0xA01F5ABF ; 11F: __thumb WSHDR * wstrcpy (WSHDR *wshdr_d,WSHDR *wshdr_s);
0480: 0xA01F5AE1 ; 120: __thumb WSHDR * wstrncpy (WSHDR *,WSHDR *,int);
0484: 0xA01F5B05 ; 121: __thumb WSHDR * wstrcat (WSHDR *wshdr_d,WSHDR *wshdr_s);
0488: 0xA01F5B39 ; 122: __thumb WSHDR * wstrncat (WSHDR *wshdr_d,WSHDR *wshdr_s,int n);
048C: 0xA01F541F ; 123: __thumb int  wstrlen (WSHDR *wshdr);
0490: 0xA0968929 ; 124: __thumb int wsprintf (WSHDR *,const char *format,...);
0494: 0xA09693ED ; 125: __thumb WSHDR * AllocWS (int len);
0498: 0xA01F5D31 ; 126: __thumb void  CutWSTR (void *WSHDR,int len);
049C: 0xA01F594F ; 127: __thumb WSHDR * CreateLocalWS (WSHDR *wshdr,unsigned __int16 *wsbody,int len);
04A0: 0xA01F59C9 ; 128: __thumb int  CreateWS (void *malloc,void *mfree,int len);
04A4: 0xA01F5351 ; 129: __thumb void  FreeWS (WSHDR *wshdr);
04A8: 0xA08FF95D ; 12A: __thumb void  DrawObject (DRWOBJ *);
04AC: 0xA096FBF5 ; 12B: __thumb void  AddKeybMsgHook (void *proc);
04B0: 0xA096FBFD ; 12C: __thumb void  AddKeybMsgHook_end (void *proc);
04B4: 0xA096FC05 ; 12D: __thumb void  RemoveKeybMsgHook (void *proc);
04B8: 0xA0971099 ; 12E: __thumb void *GetPaletteAdrByColorIndex (int ColorIndex);
04BC: 0xA09710BD ; 12F: __thumb void  getRGBcolor (int ColorIndex,void *dest);
04C0: 0xA09710CD ; 130: __thumb void  getRGBbyPaletteAdr (void *paletteAdr,void *dest);
04C4: 0xA09710EB ; 131: __thumb void  setColor (int a,int r,int g,int b,void *dest);
04C8: 0x00000000 ; 132: __thumb void  deleted();
04CC: 0xA0975931 ; 133: __thumb void  StoreXYWHtoRECT (void *RECT,int x,int y,int w,int h);
04D0: 0xA0975947 ; 134: __thumb void  StoreXYXYtoRECT (void *RECT,int x,int y,int x2,int y2);
04D4: 0xA0978233 ; 135: __thumb int  IsGuiOnTop (int id);
04D8: 0x00000000 ; 136: __unknown int  CreateGUI_ID (void *gui,int id);
04DC: 0xA0978367 ; 137: __thumb int  CreateGUI (void *gui);
04E0: 0xA0978375 ; 138: __thumb int  CreateGUI_30or2 (void *gui);
04E4: 0xA09783AF ; 139: __thumb int  CreateGUIWithDummyCSM (void *gui,int flag);
04E8: 0xA09783BF ; 13A: __thumb int  CreateGUIWithDummyCSM_30or2 (void *gui,int flag);
04EC: 0xA09783CF ; 13B: __thumb void  GeneralFuncF1 (int cmd);
04F0: 0xA09783DD ; 13C: __thumb void  GeneralFuncF0 (int cmd);
04F4: 0xA09783EB ; 13D: __thumb void  GeneralFunc_flag1 (int id,int cmd);
04F8: 0xA09783FB ; 13E: __thumb void  GeneralFunc_flag0 (int id,int cmd);
04FC: 0xA097848F ; 13F: __thumb void DirectRedrawGUI (void);
0500: 0xA09784A7 ; 140: __thumb void  DirectRedrawGUI_ID (int id);
0504: 0xA097849B ; 141: __thumb void PendedRedrawGUI (void);
0508: 0xA09FFC17 ; 142: __thumb CSM_RAM * FindCSM (void *csm_q,int id);
050C: 0xA0093318 ; 143: __arm void  GBS_StartTimer (GBSTMR *tmr,int time,int msg,int unk,int cepid);
0510: 0xA009B820 ; 144: __arm void  GBS_StopTimer (GBSTMR *tmr);
0514: 0xA0099208 ; 145: __arm int GBS_GetCurCepid (void);
0518: 0xA009B180 ; 146: __arm void LockSchedNoTskContext (void);
051C: 0xA009B26C ; 147: __arm void UnlockSchedNoTskContext (void);
0520: 0xA09778BB ; 148: __thumb int ShowMSG(int flag, int lgp_id);
0524: 0xA09733B1 ; 149: __thumb void SetPropTo_Obj1(DRWOBJ *drwobj,void *rect,int rect_flag,WSHDR *wshdr,int font,int text_flag);
0528: 0xA09715E5 ; 14A: __thumb void FreeDrawObject_subobj(DRWOBJ *drwobj);
052C: 0xA097154F ; 14B: __thumb void SetColor(DRWOBJ *drwobj, int color1, int color2);
0530: 0xA09733FB ; 14C: __thumb void DrawString(WSHDR *WSHDR,int x1,int y1,int x2,int y2,int font,int text_attribute,int Pen,int Brush);
0534: 0xA0978241 ; 14D: __thumb GUI *GetTopGUI(void);
0538: 0xA0A17DD9 ; 14E: __thumb void *FindItemByID(GUI *gui,int id);
053C: 0xA0A17E25 ; 14F: __thumb void *GetDataOfItemByID(GUI *gui,int id);
0540: 0xA0A01AEF ; 150: __thumb void DrawFrameInNativeMenu(int x1,int y1,int x2,int y2,int x_round,int y_round,int flags,int *pen,int *brush);
0544: 0xA0A02043 ; 151: __thumb void SetPropTo_Obj5(DRWOBJ *, RECT *, int zero, IMGHDR *Image);
0548: 0xA097744B ; 152: __thumb int CreateMenu(int is_small,int zero1,MENU_DESC *menu,HEADER_DESC *hdr,int zero2,int n_items,int zero4,int zero5);
054C: 0xA0091808 ; 153: __arm int GBS_RecActDstMessage(GBS_MSG *);
0550: 0xA0099180 ; 154: __arm void KillGBSproc(int cepid);
0554: 0xA00E2EE0 ; 155: __arm png_structp png_create_read_struct(png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warn_fn);
0558: 0xA00E1908 ; 156: __arm png_infop png_create_info_struct(png_structp png_ptr);
055C: 0xA00E4404 ; 157: __arm void png_destroy_read_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr, png_infopp end_info_ptr_ptr);
0560: 0xA00E170C ; 158: __arm void png_set_sig_bytes(png_structp png_ptr,int num_bytes);
0564: 0xA00E3160 ; 159: __arm void png_read_info(png_structp png_ptr, png_infop info_ptr);
0568: 0xA00E2698 ; 15A: __arm png_uint_32 png_get_IHDR(png_structp png_ptr,png_infop info_ptr, png_uint_32 *width, png_uint_32 *height, int *bit_depth, int *color_type, int *interlace_method, int *compression_method, int *filter_method);
056C: 0xA01192DC ; 15B: __arm png_voidp png_malloc(png_structp png_ptr, png_uint_32 size);
0570: 0xA00E3CE0 ; 15C: __arm void png_read_image(png_structp png_ptr, png_bytepp image);
0574: 0xA00E3D40 ; 15D: __arm void png_read_end(png_structp png_ptr, png_infop info_ptr);
0578: 0xA00E4404 ; 15E: __arm void png_destroy_read_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr, png_infopp end_info_ptr_ptr);
057C: 0xA00E22B4 ; 15F: __arm png_uint_32 png_get_rowbytes(png_structp png_ptr,png_infop info_ptr);
0580: 0xA00E3774 ; 160: __arm png_read_row(png_structp png_ptr,png_bytep row,png_bytep dsp_row);
0584: 0xA00E1E48 ; 161: __arm png_init_io(png_structp png_ptr, int fp);
0588: 0xA0FC6388 ; 162: __arm setjmp(jmp_buf jmpbuf);
058C: 0xA0A0BFB7 ; 163: __thumb EDITQ *AllocEQueue(void *malloc_a, void *mfree_a);
0590: 0xA0A0B3F5 ; 164: __thumb EDITCONTROL *PrepareEditControl(EDITCONTROL *);
0594: 0xA0A0B705 ; 165: __thumb void ConstructEditControl(EDITCONTROL *EditControl,int type,int flag,WSHDR *ws,int maxlen);
0598: 0xA0A0C153 ; 166: __thumb void AddEditControlToEditQend(void *EditQ,EDITCONTROL *EditControl,void *malloc_a);
059C: 0xA0A08D7D ; 167: __thumb int CreateInputTextDialog(const INPUTDIA_DESC *input_desc, const HEADER_DESC *header_desc,void *editq,int do_mfree,WSHDR *);
05A0: 0xA0A1205B ; 168: __thumb void SetSoftKey(void *gui,SOFTKEY_DESC *,int n);
05A4: 0xA0A11FF1 ; 169: __thumb int ExtractEditControl(void *guidata,int n,EDITCONTROL *);
05A8: 0xA0A11FFD ; 16A: __thumb int StoreEditControl(void *guidata,int n,EDITCONTROL *);
05AC: 0xA02510B8 ; 16B: __arm int unlink(const char *cFileName,unsigned int *errornumber);
05B0: 0xA02518C8 ; 16C: __arm int str_2ws(WSHDR *ws,char *str,unsigned int size);
05B4: 0xA055EE74 ; 16D: __arm int UnpackABentry(AB_UNPRES *,void *abentry,int filesz,int flag);
05B8: 0xA0505098 ; 16E: __arm int FreeUnpackABentry(AB_UNPRES *, void *mfree_adr);
05BC: 0xA0505F0C ; 16F: __arm int GetTypeOfAB_UNPRES_ITEM(int);
05C0: 0xA09557E1 ; 170: __thumb int MakeVoiceCall(char *number,int _0x10, int _0x20C0);
;Handmaded functions
;05C4: ;171 __arm void SUBPROC(void *,...); //(void (*)(void *, int),void *, int);
;05С8: ;172 __arm void REDRAW(void);

05CC: 0xA0A49221 ; 173: __thumb int socket(int af,int type,int protocol);
05D0: 0xA0A49719 ; 174: __thumb int connect(int sock,SOCK_ADDR *,int name_length);
05D4: 0xA0A4951D ; 175: __thumb int bind(int sock,SOCK_ADDR *,int name_length);
05D8: 0xA0A49A4D ; 176: __thumb int closesocket(int socket);
05DC: 0xA0A49955 ; 177: __thumb int shutdown(int socket,int how);
05E0: 0xA0A49B3F ; 178: __thumb int recv(int socket,void *buf,int len,int flag);
05E4: 0xA0A49FAD ; 179: __thumb int send(int socket,const void *buf,int len,int flag);
05E8: 0xA0A50CE9 ; 17A: __thumb unsigned __int16 htons(unsigned __int16);
05EC: 0xA0A50CF5 ; 17B: __thumb unsigned int htonl(unsigned int);
05F0: 0xA8E25BF0 ; 817C: __arm int socklasterr(void);

05F4: 0xA097840B ; 17D: __thumb void SetIDLETMR(int time_ms,int msg);
05F8: 0xA097841B ; 17E: __thumb void RestartIDLETMR(void);
05FC: 0xA0978427 ; 17F: __thumb void DisableIDLETMR(void);

0600: 0xA0A11EF5 ; 180: __thumb int EDIT_GetItemNumInFocusedComboBox(void *gui);
0604: 0xA0A11E4D ; 181: __thumb void EDIT_SetTextToFocused(void *gui,WSHDR *ws);
0608: 0xA0A11E95 ; 182: __thumb int EDIT_GetFocus(void *gui);
060C: 0xA0A118E5 ; 183: __thumb int EDIT_GetUnFocus(void *gui);
0610: 0xA0A0B73F ; 184: __thumb void ConstructComboBox(EDITCONTROL *EditControl,int type,int attr,WSHDR*,int maxlen,int unk_zero,int num_of_items,int start_item);

0614: 0xA00925C4 ;185: __arm int GBS_WaitForMsg(const int *msg_list, int msgs_num, GBS_MSG*, int timeout);
0618: 0xA09915E5 ;186: __thumb int RegisterCepidForSocketWork(REGSOCKCEPID_DATA *);
061C: 0xA09926F5 ;187: __thumb int RequestLMANConnect(LMAN_DATA *);

#pragma disable old_equal_ff
+0

;SWI_HOOK
00078000: FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 1EFF2FE100109DE5200011E3122F8F02
00078010: FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 0400000AC70050E3B000DE0103E08E02
00078020: FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 01E08E1235208FE234109FE5803CC0E3
00078030: FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 400D53E30500008A800C10E300402D09
00078040: FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 0040FD0803C191E704C08D1514208D05
00078050: FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 0100BDE800F069E10F80FDE81CFF2FE1
00078060: FFFFFFFFFFFFFFFF 60470000004007A0
;Splices
013A1288: 63685F41 048007A0
013A1374: 2C0000EA F4F01FE5


;ElfLoader+ESI+RunElfsByExtention
