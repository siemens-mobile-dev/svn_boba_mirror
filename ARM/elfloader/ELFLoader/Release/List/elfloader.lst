##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.40A/W32 EVALUATION    22/Aug/2006  13:39:33 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  E:\ARM\elfloader\ELFLoader\elfloader.cpp             #
#    Command line    =  E:\ARM\elfloader\ELFLoader\elfloader.cpp -D NDEBUG   #
#                       -lC E:\ARM\elfloader\ELFLoader\Release\List\ -lA     #
#                       E:\ARM\elfloader\ELFLoader\Release\List\ -o          #
#                       E:\ARM\elfloader\ELFLoader\Release\Obj\ -s9          #
#                       --no_unroll --cpu_mode thumb --endian little --cpu   #
#                       ARM926EJ-S --stack_align 4 --interwork -e --fpu      #
#                       None -I D:\IARARM\ARM\INC\                           #
#    List file       =  E:\ARM\elfloader\ELFLoader\Release\List\elfloader.ls #
#                       t                                                    #
#    Object file     =  E:\ARM\elfloader\ELFLoader\Release\Obj\elfloader.r79 #
#                                                                            #
#                                                                            #
##############################################################################

E:\ARM\elfloader\ELFLoader\elfloader.cpp
      1          //#define wintel		//компелим под винду
      2          
      3          #define MAX_PHNUM	10	//максимальное количество програмных сегментов
      4          
      5          #ifdef wintel
      6          #include "stdlib.h"
      7          #include "stdio.h"
      8          #include "iostream.h"
      9          #define mfree free
     10          #endif
     11          
     12          #ifndef winntel
     13          #include "E:\ARM\swilib.h"
     14          #endif
     15          
     16          typedef unsigned long  Elf32_Addr;	//Unsigned program address 4
     17          typedef unsigned short Elf32_Half;	//Unsigned medium integer  2
     18          typedef unsigned long  Elf32_Off; 	//Unsigned file offset     4
     19          typedef          long  Elf32_Sword; 	//Signed large integer     4
     20          typedef unsigned long  Elf32_Word; 	//Unsigned large integer   4
     21          
     22          //ELF Header
     23          //e_ident[] Identification Indexes
     24          #define EI_MAG0    0  //File identification
     25          #define EI_MAG1    1  //File identification
     26          #define EI_MAG2    2  //File identification
     27          #define EI_MAG3    3  //File identification
     28          #define EI_CLASS   4  //File class
     29          #define EI_DATA    5  //Data encoding
     30          #define EI_VERSION 6  //File version
     31          #define EI_PAD     7  //Start of padding bytes
     32          #define EI_NIDENT  16 //Size of e_ident[]
     33          
     34          typedef struct{
     35            unsigned char e_ident[EI_NIDENT]; //The initial bytes mark the file as an object file and provide machine-independent data with which to decode and interpret the fileТs contents.
     36            Elf32_Half e_type;      //This member identifies the object file type.
     37            Elf32_Half e_machine;   //This memberТs value specifies the required architecture for an individual file.
     38            Elf32_Word e_version;   //This member identifies the object file version.
     39            Elf32_Addr e_entry;     //This member gives the virtual address to which the system first transfers control, thus starting the process. If the file has no associated entry point, this member holds zero.
     40            Elf32_Off  e_phoff;     //This member holds the program header tableТs file offset in bytes. If the file has no program header table, this member holds zero.
     41            Elf32_Off  e_shoff;     //This member holds the section header tableТs file offset in bytes. If the file has no section header table, this member holds zero.
     42            Elf32_Word e_flags;     //This member holds processor-specific flags associated with the file. Flag names take the form EF_machine_flag.
     43            Elf32_Half e_ehsize;    //This member holds the ELF headerТs size in bytes.
     44            Elf32_Half e_phentsize; //This member holds the size in bytes of one entry in the fileТs program header table; all entries are the same size.
     45            Elf32_Half e_phnum;     //This member holds the number of entries in the program header table. Thus the product of e_phentsize and e_phnum gives the tableТs size in bytes. If a file has no program header table, e_phnum holds the value zero.
     46            Elf32_Half e_shentsize; //This member holds a section headerТs size in bytes. A section header is one entry in the section header table; all entries are the same size.
     47            Elf32_Half e_shnum;     //shnumЧThis member holds the number of entries in the section header table. Thus the product of e_shentsize and e_shnum gives the section header tableТs size in bytes. If a file has no section header table, e_shnum holds the value zero.
     48            Elf32_Half e_shstrndx;  //This member holds the section header table index of the entry associated with the section name string table. If the file has no section name string table, this member holds the value SHN_UNDEF.
     49          } Elf32_Ehdr;
     50          
     51          //E_typeЧThis member identifies the object file type.
     52          #define ET_NONE   0        //No file type
     53          #define ET_REL    1        //Re-locatable file
     54          #define ET_EXEC   2        //Executable file
     55          #define ET_DYN    3        //Shared object file
     56          #define ET_CORE   4        //Core file
     57          #define ET_LOPROC 0xFF00   //Processor-specific
     58          #define ET_HIPROC 0xFFFF   //Processor-specific
     59          
     60          //E_machineЧThis memberТs value specifies the required architecture for an individual file.
     61          #define EM_NONE        0  //No machine
     62          #define EM_M32         1  //AT&T WE 32100
     63          #define EM_SPARC       2  //SPARC
     64          #define EM_386         3  //Intel Architecture
     65          #define EM_68K         4  //Motorola 68000
     66          #define EM_88K         5  //Motorola 88000
     67          #define EM_860         7  //Intel 80860
     68          #define EM_MIPS        8  //MIPS RS3000 Big-Endian
     69          #define EM_MIPS_RS4_BE 10 //MIPS RS4000 Big-Endian
     70          #define EM_ARM         40 //ARM/Thumb Architecture
     71          
     72          //E_versionЧThis member identifies the object file version.
     73          #define EV_NONE    0 //Invalid version
     74          #define EV_CURRENT 1 //Current version
     75          
     76          //EI_MAG0 0 to EI_MAG3ЧA fileТs first 4 bytes hold a magic number, identifying the file as an ELF object file. Name Value Meaning
     77          #define ELFMAG0 0x7f //e_ident[EI_MAG0]
     78          #define ELFMAG1 'E' //e_ident[EI_MAG1]
     79          #define ELFMAG2 'L' //e_ident[EI_MAG2]
     80          #define ELFMAG3 'F' //e_ident[EI_MAG3]
     81          
     82          //EI_CLASSЧThe next byte, e_ident[EI_CLASS], identifies the fileТs class, or capacity. Name Value Meaning
     83          #define ELFCLASSNONE 0 //Invalid class
     84          #define ELFCLASS32   1 //32-bit objects
     85          #define ELFCLASS64   2 //64-bit objects
     86          
     87          //EI_DATAЧByte e_ident[EI_DATA]specifies the data encoding of all data1 in the object file. The following encodings are currently defined. Name Value Meaning
     88          #define ELFDATANONE 0 //Invalid data encoding
     89          #define ELFDATA2LSB 1 //See Data encodings ELFDATA2LSB, below
     90          #define ELFDATA2MSB 2 //See Data encodings ELFDATA2MSB, below
     91          
     92          //Sections
     93          //Section Header
     94          typedef struct{
     95            Elf32_Word sh_name;      //This member specifies the name of the section. Its value is an index into the section header string table section [see section 3.4, String Table below], giving the location of a null-terminated string.
     96            Elf32_Word sh_type;      //typeЧThis member categorizes the sectionТs contents and semantics. Section types and their descriptions appear in Figure 3-9 below.
     97            Elf32_Word sh_flags;     //Sections support 1-bit flags that describe miscellaneous attributes. Flag definitions appear in Figure 3-11, below.
     98            Elf32_Addr sh_addr;      //If the section will appear in the memory image of a process, this member gives the address at which the sectionТs first byte should reside. Otherwise, the member contains 0.
     99            Elf32_Off  sh_offset;    //This memberТs value gives the byte offset from the beginning of the file to the first byte in the section. One section type, SHT_NOBITS described in Figure 3-9 below, occupies no space in the file, and its sh_offset member locates the conceptual placement in the file.
    100            Elf32_Word sh_size;      //This member gives the sectionТs size in bytes. Unless the section type is SHT_NOBITS, the section occupies sh_size bytes in the file. A section of type SHT_NOBITS may have a non-zero size, but it occupies no space in the file.
    101            Elf32_Word sh_link;      //This member holds a section header table index link, whose interpretation depends on the section type. Figure 3-12 below describes the values.
    102            Elf32_Word sh_info;      //This member holds extra information, whose interpretation depends on the section type. Figure 3-12 below describes the values.
    103            Elf32_Word sh_addralign; //Some sections have address alignment constraints. For example, if a section holds a doubleword, the system must ensure double-word alignment for the entire section. That is, the value of sh_addr must be congruent to 0, modulo the value of sh_addralign. Currently, only 0 and positive integral powers of two are allowed. Values 0 and 1 mean the section has no alignment constraints.
    104            Elf32_Word sh_entsize;   //Some sections hold a table of fixed-size entries, such as a symbol table. For such a section, this member gives the size in bytes of each entry. The member contains 0 if the section does not hold a table of fixedsize entries. A section headerТs sh_type member specifies the sectionТs semantics.
    105          } Elf32_Shdr;
    106          
    107          //Special Section Indexes
    108          #define SHN_UNDEF     0     //This value marks an undefined, missing, irrelevant, or otherwise meaningless section reference. For example, a symbol УdefinedФ relative to section number SHN_UNDEF is an undefined symbol.
    109          #define SHN_LORESERVE 0xff00 //This value specifies the lower bound of the range of reserved indexes.
    110          #define SHN_LOPROC    0xff00 //Values in this range are reserved for processor-specific semantics.
    111          #define SHN_HIPROC    0xff1f //Values in this range are reserved for processor-specific semantics.
    112          #define SHN_ABS       0xfff1 //This value specifies absolute values for the corresponding reference. For example, symbols defined relative to section number SHN_ABS have absolute values and are not affected by relocation.
    113          #define SHN_COMMON    0xfff2 //Symbols defined relative to this section are common symbols, such as FORTRAN COMMON or unallocated C external variables.
    114          #define SHN_HIRESERVE 0xffff //This value specifies the upper bound of the range of reserved indexes. The system reserves indexes between SHN_LORESERVE and SHN_HIRESERVE, inclusive; the values do not refer to the section header table. That is, the section header table does not contain entries for the reserved indexes.
    115          
    116          //sh_type
    117          #define SHT_NULL     0  //This value marks a section header that does not have an associated section. Other members of the section header have undefined values
    118          #define SHT_PROGBITS 1  //The section holds information defined by the program, whose format and meaning are determined solely by the program.
    119          #define SHT_SYMTAB   2  //The section holds a symbol table.
    120          #define SHT_STRTAB   3  //The section holds a string table.
    121          #define SHT_RELA     4  //The section holds relocation entries with explicit addends, such as type Elf32_Rela for the 32-bit class of object files. An object file may have multiple relocation sections. See Relocation below for details.
    122          #define SHT_HASH     5  //The section holds a symbol hash table.
    123          #define SHT_DYNAMIC  6  //The section holds information for dynamic linking.
    124          #define SHT_NOTE     7  //This section holds information that marks the file in some way.
    125          #define SHT_NOBITS   8  //A section of this type occupies no space in the file but otherwise resembles SHT_PROGBITS. Although this section contains no bytes, the sh_offset member contains the conceptual file offset.
    126          #define SHT_REL      9  //The section holds relocation entries without explicit addends, such as type Elf32_Rel for the 32-bit class of object files. An object file may have multiple relocation sections. See Relocation below for details.
    127          #define SHT_SHLIB    10 //This section type is reserved but has unspecified semantics.
    128          #define SHT_DYNSYM   11 //The section holds a symbol table.
    129          #define SHT_LOPROC   0x70000000
    130          #define SHT_HIPROC   0x7fffffff //Values in this inclusive range are reserved for processor-specific semantics.
    131          #define SHT_LOUSER   0x80000000
    132          #define SHT_HIUSER   0xffffffff //Values in this inclusive range are reserved for application programs. Types between SHT_LOUSER and SHT_HIUSER may be used by an application,without conflicting with current or future system-defined section types.
    133          
    134          //Section Attribute Flags, sh_flags
    135          #define SHF_WRITE     1          //The section contains data that should be writable during process execution
    136          #define SHF_ALLOC     2          //The section occupies memory during process execution. Some control sections do not reside in the memory image of an object file; this attribute is off for those sections
    137          #define SHF_EXECINSTR 4          //The section contains executable machine instructions.
    138          #define SHF_MASKPROC  0xf0000000 //Bits in this mask are reserved for processor-specific semantics.
    139          
    140          //Program
    141          //Program Header
    142          typedef struct{
    143            Elf32_Word p_type;   //This member tells what kind of segment this array element describes or how to interpret the array element's information. Type values and their meanings are given in Figure 3-21, below.
    144            Elf32_Off p_offset;  //This member gives the offset from the start of the file at which the first byte of the segment resides.
    145            Elf32_Addr p_vaddr;  //This member gives the virtual address at which the first byte of the segment resides in memory.
    146            Elf32_Addr p_paddr;  //On systems for which physical addressing is relevant, this member is reserved for the segment's physical address. This member requires operating system specific information.
    147            Elf32_Word p_filesz; //This member gives the number of bytes in the file image of the segment; it may be zero.
    148            Elf32_Word p_memsz;  //This member gives the number of bytes in the memory image of the segment; it may be zero.
    149            Elf32_Word p_flags;  //This member gives flags relevant to the segment. Defined flag values are given in Figure 3-22, below.
    150            Elf32_Word p_align;  //Loadable process segments must have congruent values for p_vaddr and p_offset, modulo the page size. This member gives the value to which the segments are aligned in memory and in the file. Values 0 and 1 mean that no alignment is required. Otherwise, p_align should be a positive, integral power of 2, and p_vaddr should equal p_offset, modulo p_align.
    151          } Elf32_Phdr;
    152          
    153          //Defined program header flags
    154          #define PF_X 1 //The segment may be executed.
    155          #define PF_W 2 //The segment may be written to.
    156          #define PF_R 4 //The segment may be read.
    157          #define PF_MASKPROC 0xf0000000 //Reserved for processor-specific purposes (see 4.6, Program headers).
    158          
    159          //Segment Types, p_type
    160          #define PT_NULL    0 //The array element is unused; other members' values are undefined. This type lets the program header table have ignored entries.
    161          #define PT_LOAD    1 //The array element specifies a loadable segment, described by p_filesz and p_memsz (for additional explanation, see PT_LOAD below).
    162          #define PT_DYNAMIC 2 //The array element specifies dynamic linking information. See subsection 4.7.
    163          #define PT_INTERP  3 //The array element specifies the location and size of a null-terminated path name to invoke as an interpreter.
    164          #define PT_NOTE    4 //The array element specifies the location and size of auxiliary information.
    165          #define PT_SHLIB   5 //This segment type is reserved but has unspecified semantics.
    166          #define PT_PHDR    6 //The array element, if present, specifies the location and size of the program header table itself (for additional explanation, see PT_ PHDR below).
    167          #define PT_LOPROC  0x70000000 //Values in this inclusive range are reserved for processor-specific semantics.
    168          #define PT_HIPROC  0x7fffffff
    169          
    170          //The dynamic section
    171          typedef struct{
    172            Elf32_Sword d_tag;
    173            Elf32_Word d_val;
    174          } Elf32_Dyn;
    175          
    176          //Dynamic section tags
    177          #define DT_NULL     0  //Ignored. This entry marks the end of the dynamic array. mandatory
    178          #define DT_NEEDED   1  //Index in the string table of the name of a needed library. multiple
    179          #define DT_PLTRELSZ 2  //These entries are unused by versions 1-2 of the ARM EABI. unused
    180          #define DT_PLTGOT   3
    181          #define DT_HASH     4  //The offset of the hash table section in the dynamic segment. mandatory
    182          #define DT_STRTAB   5  //The offset of the string table section in the dynamic segment. mandatory
    183          #define DT_SYMTAB   6  //The offset of the symbol table section in the dynamic segment. mandatory
    184          #define DT_RELA     7  //The offset in the dynamic segment of an SHT_RELA relocation section, Its byte size, and the byte size of an ARM RELA-type relocation entry. optional
    185          #define DT_RELASZ   8
    186          #define DT_RELAENT  9
    187          #define DT_STRSZ    10 //The byte size of the string table section. mandatory
    188          #define DT_SYMENT   11 //The byte size of an ARM symbol table entryЧ16. mandatory
    189          #define DT_INIT     12 //These entries are unused by versions 1-2 of the ARM EABI. unused
    190          #define DT_FINI     13
    191          #define DT_SONAME   14 //The Index in the string table of the name of this shared object. mandatory
    192          #define DT_RPATH    15 //Unused by the ARM EABI. unused
    193          #define DT_SYMBOLIC 16
    194          #define DT_REL      17 //The offset in the dynamic segment of an SHT_REL relocation section, Its byte size, and the byte size of an ARM REL-type relocation entry optional
    195          #define DT_RELSZ    18
    196          #define DT_RELENT   19
    197          #define DT_PLTREL   20 //These entries are unused by versions 1-2 of the ARM EABI. unused
    198          #define DT_DEBUG    21
    199          #define DT_TEXTREL  22
    200          #define DT_JMPREL   23
    201          #define DT_BIND_NOW 24
    202          #define DT_LOPROC   0x70000000 //Values in this range are reserved to the ARM EABI. unused
    203          #define DT_HIPROC   0x7fffffff
    204          
    205          //Relocation Entries
    206          typedef struct{
    207            Elf32_Addr r_offset;
    208            Elf32_Word r_info;
    209          } Elf32_Rel;
    210          
    211          #define ELF32_R_SYM(i) ((i)>>8)
    212          #define ELF32_R_TYPE(i) ((unsigned char)(i))
    213          #define ELF32_R_INFO(s,t) (((s)<<8)+(unsigned char)(t))
    214          
    215          //ARM relocation types
    216          #define R_ARM_NONE            0   //Any No relocation. Encodes dependencies between sections.
    217          #define R_ARM_PC24            1   //ARM B/BL S Ц P + A
    218          #define R_ARM_ABS32           2   //32-bit word S + A
    219          #define R_ARM_REL32           3   //32-bit word S Ц P + A
    220          #define R_ARM_PC13            4   //ARM LDR r, [pc,Е] S Ц P + A
    221          #define R_ARM_ABS16           5   //16-bit half-word S + A
    222          #define R_ARM_ABS12           6   //ARM LDR/STR S + A
    223          #define R_ARM_THM_ABS5        7   //Thumb LDR/STR S + A
    224          #define R_ARM_ABS8            8   //8-bit byte S + A
    225          #define R_ARM_SBREL32         9   //32-bit word S Ц B + A
    226          #define R_ARM_THM_PC22        10  //Thumb BL pair S Ц P+ A
    227          #define R_ARM_THM_PC8         11  //Thumb LDR r, [pc,Е] S Ц P + A
    228          #define R_ARM_AMP_VCALL9      12  //AMP VCALL ObsoleteЧSA-1500 only.
    229          #define R_ARM_SWI24           13  //ARM SWI S + A
    230          #define R_ARM_THM_SWI8        14  //Thumb SWI S + A
    231          #define R_ARM_XPC25           15  //ARM BLX S Ц P+ A
    232          #define R_ARM_THM_XPC22       16  //Thumb BLX pair S Ц P+ A
    233          #define R_ARM_COPY            20  //32 bit word Copy symbol at dynamic link time.
    234          #define R_ARM_GLOB_DAT        21  //32 bit word Create GOT entry.
    235          #define R_ARM_JUMP_SLOT       22  //32 bit word Create PLT entry.
    236          #define R_ARM_RELATIVE        23  //32 bit word Adjust by program base.
    237          #define R_ARM_GOTOFF          24  //32 bit word Offset relative to start of GOT.
    238          #define R_ARM_GOTPC           25  //32 bit word Insert address of GOT.
    239          #define R_ARM_GOT32           26  //32 bit word Entry in GOT.
    240          #define R_ARM_PLT32           27  //ARM BL Entry in PLT.
    241          #define R_ARM_ALU_PCREL_7_0   32  //ARM ADD/SUB (S Ц P + A) & 0x000000FF
    242          #define R_ARM_ALU_PCREL_15_8  33  //ARM ADD/SUB (S Ц P + A) & 0x0000FF00
    243          #define R_ARM_ALU_PCREL_23_15 34  //ARM ADD/SUB (S Ц P + A) & 0x00FF0000
    244          #define R_ARM_LDR_SBREL_11_0  35  //ARM LDR/STR (S Ц B + A) & 0x00000FFF
    245          #define R_ARM_ALU_SBREL_19_12 36  //ARM ADD/SUB (S Ц B + A) & 0x000FF000
    246          #define R_ARM_ALU_SBREL_27_20 37  //ARM ADD/SUB (S Ц B + A) & 0x0FF00000
    247          #define R_ARM_GNU_VTENTRY     100 //32 bit word Record C++ vtable entry.
    248          #define R_ARM_GNU_VTINHERIT   101 //32 bit word Record C++ member usage.
    249          #define R_ARM_THM_PC11        102 //Thumb B S Ц P + A
    250          #define R_ARM_THM_PC9         103 //Thumb B<cond> S Ц P + A
    251          #define R_ARM_RXPC25          249 //ARM BLX (?S Ц ?P) + A For calls between program segments.
    252          #define R_ARM_RSBREL32        250 //Word (?S Ц ?SB) + A For an offset from SB, the static base.
    253          #define R_ARM_THM_RPC22       251 //Thumb BL/BLX pair (?S Ц ?P) + A For calls between program segments.
    254          #define R_ARM_RREL32          252 //Word (?S Ц ?P) + A For on offset between two segments.
    255          #define R_ARM_RABS32          253 //Word ?S + A For the address of a location in the target segment.
    256          #define R_ARM_RPC24           254 //ARM B/BL (?S Ц ?P) + A For calls between program segments.
    257          #define R_ARM_RBASE           255 //None NoneЧIdentifies the segment being relocated by the following relocation directives.
    258          
    259          typedef long TElfEntry(char *, void *,void *,void *);
    260          

   \                                 In segment CODE, align 4, keep-with-next
    261          __arm zeromem_a(void *d, int l){zeromem(d,l);}
   \                     zeromem_a:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   1D0100EF           SWI      +285
   \   00000008   0080BDE8           POP      {PC}             ;; return
    262          

   \                                 In segment CODE, align 4, keep-with-next
    263          long elfload(char *filename, void *param1, void *param2, void *param3){
   \                     elfload:
   \   00000000   FFB5               PUSH     {R0-R7,LR}
   \   00000002   FCB0               SUB      SP,SP,#+496
    264            Elf32_Ehdr ehdr;				                        //заголовок ельфа
    265            Elf32_Phdr phdrs[MAX_PHNUM];	                                        //заголовки програм
    266            Elf32_Word dyn[DT_BIND_NOW+1];	                                        //тэги динамической секции
    267            char *reloc, *base;
    268            unsigned long minadr=(unsigned long)-1, maxadr=0;//, maxadrsize;
   \   00000004   0025               MOVS     R5,#+0
   \   00000006   ED43               MVNS     R5,R5
   \   00000008   0295               STR      R5,[SP, #+8]
   \   0000000A   0026               MOVS     R6,#+0
    269            int n,m;
    270            /////////////////////////////////////////
    271            //WINTEL
    272          #ifdef wintel
    273            FILE *fin=NULL;
    274          
    275            if ((fin=fopen(filename,"rb"))==NULL) return -1;			//не открываетс€ ельф
    276            if (fread(&ehdr,sizeof(Elf32_Ehdr),1,fin)!=1) return -2;	        //не читаетс€ ельф
    277          #endif
    278          
    279            //ARM
    280          #ifndef wintel
    281            int fin;
    282            unsigned int iError, iError2;
    283            if ((fin=fopen(filename, A_ReadOnly+A_BIN, P_READ, &iError))<0) return -1;	//не открываетс€ ельф
   \   0000000C   6B46               MOV      R3,SP
   \   0000000E   8022               MOVS     R2,#+128
   \   00000010   1102               LSLS     R1,R2,#+8
   \   00000012   0ADF               SVC      +10
   \   00000014   0400               MOVS     R4,R0
   \   00000016   01D5               BPL      ??elfload_0
   \   00000018   2800               MOVS     R0,R5
   \   0000001A   12E1               B        ??elfload_1
    284            if (fread(fin, &ehdr, sizeof(Elf32_Ehdr), &iError)!=sizeof(Elf32_Ehdr))	//не читаетс€ ельф
   \                     ??elfload_0:
   \   0000001C   6B46               MOV      R3,SP
   \   0000001E   3422               MOVS     R2,#+52
   \   00000020   06A9               ADD      R1,SP,#+24
   \   00000022   0BDF               SVC      +11
   \   00000024   3428               CMP      R0,#+52
   \   00000026   05D0               BEQ      ??elfload_2
    285            {fclose(fin, &iError); return -2;}
   \   00000028   6946               MOV      R1,SP
   \   0000002A   2000               MOVS     R0,R4
   \   0000002C   0DDF               SVC      +13
   \   0000002E   0120               MOVS     R0,#+1
   \                     ??elfload_3:
   \   00000030   C043               MVNS     R0,R0
   \   00000032   06E1               B        ??elfload_1
    286          #endif
    287            /////////////////////////////////////////
    288          
    289            if (*((long *)ehdr.e_ident)!=0x464C457F){                               //да и не ельф это вовсе
   \                     ??elfload_2:
   \   00000034   0698               LDR      R0,[SP, #+24]
   \   00000036   8449               LDR      R1,??elfload_4   ;; 0x464c457f
   \   00000038   8842               CMP      R0,R1
   \   0000003A   04D0               BEQ      ??elfload_5
    290          #ifndef wintel
    291              fclose(fin, &iError);
   \   0000003C   6946               MOV      R1,SP
   \   0000003E   2000               MOVS     R0,R4
   \   00000040   0DDF               SVC      +13
    292          #endif
    293              return -3;
   \   00000042   0220               MOVS     R0,#+2
   \   00000044   F4E7               B.N      ??elfload_3
    294            }
   \                     ??elfload_5:
   \   00000046   06A8               ADD      R0,SP,#+24
   \   00000048   808D               LDRH     R0,[R0, #+44]
   \   0000004A   0B28               CMP      R0,#+11
   \   0000004C   02D3               BCC      ??elfload_6
    295          
    296          #ifdef wintel
    297            cout << "Elf header"<<endl;
    298            cout << "ehdr.e_entry:"<<ehdr.e_entry<<endl;
    299            cout << "ehdr.e_phoff:"<<ehdr.e_phoff<<endl;
    300          #endif
    301          
    302            //прочитаем все програмные сегменты и вычислим необходимую область в раме
    303            if (ehdr.e_phnum>MAX_PHNUM) return -9;					//слишком много програмных сегментов
   \   0000004E   0820               MOVS     R0,#+8
   \                     ??elfload_7:
   \   00000050   C043               MVNS     R0,R0
   \   00000052   F6E0               B        ??elfload_1
    304            for(n=0;n<ehdr.e_phnum;n++){
   \                     ??elfload_6:
   \   00000054   0025               MOVS     R5,#+0
   \   00000056   13AF               ADD      R7,SP,#+76
   \   00000058   0837               ADDS     R7,R7,#+8
   \   0000005A   11E0               B        ??elfload_8
    305              ////////////////////////////////////////////////////
    306              //WINTEL
    307          #ifdef wintel
    308              if (fseek(fin,ehdr.e_phoff+n*ehdr.e_phentsize,SEEK_SET)!=0) return -4;	//не сикаетс€ програмный заголовок
    309              if (fread(&(phdrs[n]),sizeof(Elf32_Phdr),1,fin)!=1) return -5;		//не читаетс€ програмный заголовок
    310          #endif
    311          
    312              //ARM
    313          #ifndef wintel
    314              if (lseek(fin, ehdr.e_phoff+n*ehdr.e_phentsize, S_SET, &iError, &iError2)!=ehdr.e_phoff+n*ehdr.e_phentsize)
    315              {fclose(fin, &iError); return -4;}				//не сикаетс€ програмный заголовок
    316              if (fread(fin, &phdrs[n], sizeof(Elf32_Phdr), &iError)!=sizeof(Elf32_Phdr))
    317              {fclose(fin, &iError); return -5;}				//не читаетс€ програмный заголовок
    318          #endif
    319              /////////////////////////////////////////////////////
    320              if (phdrs[n].p_type==PT_LOAD) {
   \                     ??elfload_9:
   \   0000005C   3800               MOVS     R0,R7
   \   0000005E   0838               SUBS     R0,R0,#+8
   \   00000060   0068               LDR      R0,[R0, #+0]
   \   00000062   0128               CMP      R0,#+1
   \   00000064   0AD1               BNE      ??elfload_10
    321                if (minadr>phdrs[n].p_vaddr) minadr=phdrs[n].p_vaddr;
   \   00000066   3868               LDR      R0,[R7, #+0]
   \   00000068   0299               LDR      R1,[SP, #+8]
   \   0000006A   8842               CMP      R0,R1
   \   0000006C   00D2               BCS      ??elfload_11
   \   0000006E   0290               STR      R0,[SP, #+8]
    322                if (maxadr<(phdrs[n].p_vaddr+phdrs[n].p_memsz))
   \                     ??elfload_11:
   \   00000070   F968               LDR      R1,[R7, #+12]
   \   00000072   4018               ADDS     R0,R0,R1
   \   00000074   8642               CMP      R6,R0
   \   00000076   01D2               BCS      ??elfload_10
    323                {
    324          	maxadr=phdrs[n].p_vaddr+phdrs[n].p_memsz;
   \   00000078   3868               LDR      R0,[R7, #+0]
   \   0000007A   4618               ADDS     R6,R0,R1
    325                }
    326              }
   \                     ??elfload_10:
   \   0000007C   6D1C               ADDS     R5,R5,#+1
   \   0000007E   2037               ADDS     R7,R7,#+32
   \                     ??elfload_8:
   \   00000080   06A8               ADD      R0,SP,#+24
   \   00000082   808D               LDRH     R0,[R0, #+44]
   \   00000084   8542               CMP      R5,R0
   \   00000086   24DA               BGE      ??elfload_12
   \   00000088   05A8               ADD      R0,SP,#+20
   \   0000008A   01B4               PUSH     {R0}
   \   0000008C   0E98               LDR      R0,[SP, #+56]
   \   0000008E   07A9               ADD      R1,SP,#+28
   \   00000090   498D               LDRH     R1,[R1, #+42]
   \   00000092   01AB               ADD      R3,SP,#+4
   \   00000094   0022               MOVS     R2,#+0
   \   00000096   6943               MULS     R1,R5,R1
   \   00000098   4118               ADDS     R1,R0,R1
   \   0000009A   2000               MOVS     R0,R4
   \   0000009C   0FDF               SVC      +15
   \   0000009E   0E99               LDR      R1,[SP, #+56]
   \   000000A0   07AA               ADD      R2,SP,#+28
   \   000000A2   528D               LDRH     R2,[R2, #+42]
   \   000000A4   01B0               ADD      SP,SP,#+4
   \   000000A6   6A43               MULS     R2,R5,R2
   \   000000A8   8918               ADDS     R1,R1,R2
   \   000000AA   8842               CMP      R0,R1
   \   000000AC   04D0               BEQ      ??elfload_13
   \   000000AE   6946               MOV      R1,SP
   \   000000B0   2000               MOVS     R0,R4
   \   000000B2   0DDF               SVC      +13
   \   000000B4   0320               MOVS     R0,#+3
   \   000000B6   BBE7               B.N      ??elfload_3
   \                     ??elfload_13:
   \   000000B8   6B46               MOV      R3,SP
   \   000000BA   2022               MOVS     R2,#+32
   \   000000BC   3900               MOVS     R1,R7
   \   000000BE   0839               SUBS     R1,R1,#+8
   \   000000C0   2000               MOVS     R0,R4
   \   000000C2   0BDF               SVC      +11
   \   000000C4   2028               CMP      R0,#+32
   \   000000C6   C9D0               BEQ      ??elfload_9
   \   000000C8   6946               MOV      R1,SP
   \   000000CA   2000               MOVS     R0,R4
   \   000000CC   0DDF               SVC      +13
   \   000000CE   0420               MOVS     R0,#+4
   \   000000D0   BEE7               B.N      ??elfload_7
    327          #ifdef wintel
    328              cout << "Program header"<<endl;
    329              cout << "phdr.p_type:"<<phdrs[n].p_type<<endl;
    330              cout << "phdr.p_offset:"<<phdrs[n].p_offset<<endl;
    331              cout << "phdr.p_vaddr:"<<phdrs[n].p_vaddr<<endl;
    332              cout << "phdr.p_paddr:"<<phdrs[n].p_paddr<<endl;
    333              cout << "phdr.p_filesz:"<<phdrs[n].p_filesz<<endl;
    334          #endif
    335            }
    336          
    337            //выделим эту область и очистим ее
    338            if ((base=(char *)malloc(maxadr-minadr))==0){		//не выдел€етьс€ пам€ть под ельф
   \                     ??elfload_12:
   \   000000D2   0298               LDR      R0,[SP, #+8]
   \   000000D4   351A               SUBS     R5,R6,R0
   \   000000D6   2800               MOVS     R0,R5
   \   000000D8   14DF               SVC      +20
   \   000000DA   0600               MOVS     R6,R0
   \   000000DC   04D1               BNE      ??elfload_14
    339          #ifndef wintel
    340              fclose(fin, &iError);
   \   000000DE   6946               MOV      R1,SP
   \   000000E0   2000               MOVS     R0,R4
   \   000000E2   0DDF               SVC      +13
    341          #endif
    342              return -14;
   \   000000E4   0D20               MOVS     R0,#+13
   \   000000E6   A3E7               B.N      ??elfload_3
    343            }
    344            zeromem_a(base,maxadr-minadr);
   \                     ??elfload_14:
   \   000000E8   2900               MOVS     R1,R5
   \   000000EA   ........           BLX      zeromem_a
    345            for(n=0;n<ehdr.e_phnum;n++){
   \   000000EE   0025               MOVS     R5,#+0
   \   000000F0   13A8               ADD      R0,SP,#+76
   \   000000F2   52E0               B.N      ??elfload_15
    346              ////////////////////////////////////////////////////////////////////
    347              //WINTEL
    348          #ifdef wintel
    349              if (fseek(fin,phdrs[n].p_offset,SEEK_SET)!=0) return -6;	//не сикаетс€ динамический сегмент
    350          #endif
    351          
    352              //ARM
    353          #ifndef wintel
    354              if (lseek(fin, phdrs[n].p_offset, S_SET, &iError, &iError)!=phdrs[n].p_offset)
    355              {fclose(fin, &iError); mfree(base); return -6;}		//не сикаетс€ динамический сегмент
    356          #endif
    357              /////////////////////////////////////////////////////////////////////
    358              switch (phdrs[n].p_type){
   \                     ??elfload_16:
   \   000000F4   0198               LDR      R0,[SP, #+4]
   \   000000F6   0068               LDR      R0,[R0, #+0]
   \   000000F8   0128               CMP      R0,#+1
   \   000000FA   02D0               BEQ      ??elfload_17
   \   000000FC   0228               CMP      R0,#+2
   \   000000FE   17D0               BEQ      ??elfload_18
   \   00000100   89E0               B        ??elfload_19
    359              case PT_LOAD:
    360                //загрузем програмные сегменты с размером больше 0
    361                if (phdrs[n].p_filesz!=0) {
   \                     ??elfload_17:
   \   00000102   0198               LDR      R0,[SP, #+4]
   \   00000104   0269               LDR      R2,[R0, #+16]
   \   00000106   002A               CMP      R2,#+0
   \   00000108   44D0               BEQ      ??elfload_20
    362          	/////////////////////////////////////////////////////////////////////
    363          	//WINTEL
    364          #ifdef wintel
    365          	if (fread((void *)&base[phdrs[n].p_vaddr-minadr],phdrs[n].p_filesz,1,fin)!=1) return -11;	//не читаетс€ програмный сегмент
    366          #endif
    367          	
    368          	//ARM
    369          #ifndef wintel
    370          	if (fread(fin, &base[phdrs[n].p_vaddr-minadr], phdrs[n].p_filesz, &iError)!= phdrs[n].p_filesz)
   \   0000010A   8068               LDR      R0,[R0, #+8]
   \   0000010C   0299               LDR      R1,[SP, #+8]
   \   0000010E   6B46               MOV      R3,SP
   \   00000110   401A               SUBS     R0,R0,R1
   \   00000112   3118               ADDS     R1,R6,R0
   \   00000114   2000               MOVS     R0,R4
   \   00000116   0BDF               SVC      +11
   \   00000118   0199               LDR      R1,[SP, #+4]
   \   0000011A   0969               LDR      R1,[R1, #+16]
   \   0000011C   8842               CMP      R0,R1
   \   0000011E   39D0               BEQ      ??elfload_20
    371          	{fclose(fin, &iError); mfree(base); return -11;}//не читаетс€ програмный сегмент
   \   00000120   6946               MOV      R1,SP
   \   00000122   2000               MOVS     R0,R4
   \   00000124   0DDF               SVC      +13
   \   00000126   3000               MOVS     R0,R6
   \   00000128   15DF               SVC      +21
   \   0000012A   0A20               MOVS     R0,#+10
   \                     ??elfload_21:
   \   0000012C   C043               MVNS     R0,R0
   \   0000012E   88E0               B        ??elfload_1
    372          #endif
    373          	///////////////////////////////////////////////////////////////////////
    374                }
    375                break;
    376              case PT_DYNAMIC:
    377                //прочтем динамическую секцию
    378                if ((reloc=(char *)malloc(phdrs[n].p_filesz))==0) {//не выдел€етс€ рама под динамический сегмент
   \                     ??elfload_18:
   \   00000130   0198               LDR      R0,[SP, #+4]
   \   00000132   0069               LDR      R0,[R0, #+16]
   \   00000134   14DF               SVC      +20
   \   00000136   0700               MOVS     R7,R0
   \   00000138   06D1               BNE      ??elfload_22
    379          #ifndef wintel
    380          	fclose(fin, &iError);
   \   0000013A   6946               MOV      R1,SP
   \   0000013C   2000               MOVS     R0,R4
   \   0000013E   0DDF               SVC      +13
    381          #endif
    382          	mfree(base);
   \   00000140   3000               MOVS     R0,R6
   \   00000142   15DF               SVC      +21
    383          	return -7;
   \   00000144   0620               MOVS     R0,#+6
   \   00000146   73E7               B.N      ??elfload_3
    384                }
    385                ///////////////////////////////////////////////////////////////////////
    386                //WINTEL
    387          #ifdef wintel
    388                if (fread(reloc,phdrs[n].p_filesz,1,fin)!=1) {mfree(reloc); return -8;} //не читаетс€ динамический сегмент
    389          #endif
    390          
    391                //ARM
    392          #ifndef wintel
    393                if (fread(fin, reloc, phdrs[n].p_filesz, &iError)!=phdrs[n].p_filesz)
   \                     ??elfload_22:
   \   00000148   0198               LDR      R0,[SP, #+4]
   \   0000014A   6B46               MOV      R3,SP
   \   0000014C   0269               LDR      R2,[R0, #+16]
   \   0000014E   3900               MOVS     R1,R7
   \   00000150   2000               MOVS     R0,R4
   \   00000152   0BDF               SVC      +11
   \   00000154   0199               LDR      R1,[SP, #+4]
   \   00000156   0969               LDR      R1,[R1, #+16]
   \   00000158   8842               CMP      R0,R1
   \   0000015A   08D0               BEQ      ??elfload_23
    394                {fclose(fin, &iError); mfree(reloc); mfree (base); return -8;}	//не читаетс€ динамический сегмент
   \   0000015C   6946               MOV      R1,SP
   \   0000015E   2000               MOVS     R0,R4
   \   00000160   0DDF               SVC      +13
   \   00000162   3800               MOVS     R0,R7
   \   00000164   15DF               SVC      +21
   \   00000166   3000               MOVS     R0,R6
   \   00000168   15DF               SVC      +21
   \   0000016A   0720               MOVS     R0,#+7
   \   0000016C   70E7               B.N      ??elfload_7
    395          #endif
    396                ////////////////////////////////////////////////////////////////////////
    397                //				memset(dyn,0, sizeof(dyn));
    398                //вытащим все тэги из динамической секции
    399                m=0;
   \                     ??elfload_23:
   \   0000016E   3800               MOVS     R0,R7
   \   00000170   06E0               B        ??elfload_24
    400                while (((Elf32_Dyn *)reloc)[m].d_tag!=0){
    401          	if (((Elf32_Dyn *)reloc)[m].d_tag<=DT_BIND_NOW) {
   \                     ??elfload_25:
   \   00000172   1929               CMP      R1,#+25
   \   00000174   03DA               BGE      ??elfload_26
    402          	  dyn[((Elf32_Dyn *)reloc)[m].d_tag]=((Elf32_Dyn *)reloc)[m].d_val;
   \   00000176   4268               LDR      R2,[R0, #+4]
   \   00000178   8B00               LSLS     R3,R1,#+2
   \   0000017A   63A9               ADD      R1,SP,#+396
   \   0000017C   CA50               STR      R2,[R1, R3]
    403          	}
    404          	m++;
   \                     ??elfload_26:
   \   0000017E   0830               ADDS     R0,R0,#+8
    405                }
   \                     ??elfload_24:
   \   00000180   0168               LDR      R1,[R0, #+0]
   \   00000182   0029               CMP      R1,#+0
   \   00000184   F5D1               BNE      ??elfload_25
    406          #ifdef wintel
    407                cout << "Dynamic section" << endl;
    408                for (m = 0; m <= DT_BIND_NOW; m++) {
    409          	cout << m<<" = "<<dyn[m]<<endl;
    410                }
    411          #endif
    412                m=0;
    413                //выполним релокацию REL
    414                if (dyn[DT_RELSZ]!=0) {
   \   00000186   7599               LDR      R1,[SP, #+468]
   \   00000188   0020               MOVS     R0,#+0
   \   0000018A   0391               STR      R1,[SP, #+12]
   \   0000018C   0029               CMP      R1,#+0
   \   0000018E   2BD1               BNE      ??elfload_27
    415          	while (m*sizeof(Elf32_Rel)<dyn[DT_RELSZ]){
    416          #ifdef wintel
    417          	  cout<<((Elf32_Rel *)(reloc+dyn[DT_REL]))[m].r_offset
    418          	    <<" , "<<ELF32_R_SYM(((Elf32_Rel *)(reloc+dyn[DT_REL]))[m].r_info)
    419          	      <<" , "<<(int) ELF32_R_TYPE(((Elf32_Rel *)(reloc+dyn[DT_REL]))[m].r_info)<<endl;
    420          #endif
    421          	  switch(ELF32_R_TYPE(((Elf32_Rel *)(reloc+dyn[DT_REL]))[m].r_info)){
    422          	  case R_ARM_RABS32:
    423          	    *((long*)(base+((Elf32_Rel *)(reloc+dyn[DT_REL]))[m].r_offset-minadr))+=(long)base-minadr;
    424          	    break;
    425          	  case R_ARM_RBASE: break;
    426          	  default: 	//неизвестный тип релокации
    427          #ifndef wintel
    428          	    fclose(fin, &iError);
    429          #endif
    430          	    mfree(base);
    431          	    mfree(reloc);
    432          	    return -13;
    433          	  }
    434          	  m++;
    435          	}
    436                }
    437                mfree(reloc);
   \                     ??elfload_28:
   \   00000190   3800               MOVS     R0,R7
   \   00000192   15DF               SVC      +21
   \                     ??elfload_20:
   \   00000194   0198               LDR      R0,[SP, #+4]
   \   00000196   6D1C               ADDS     R5,R5,#+1
   \   00000198   2030               ADDS     R0,R0,#+32
   \                     ??elfload_15:
   \   0000019A   0190               STR      R0,[SP, #+4]
   \   0000019C   0298               LDR      R0,[SP, #+8]
   \   0000019E   4142               RSBS     R1,R0,#+0
   \   000001A0   0491               STR      R1,[SP, #+16]
   \   000001A2   06A8               ADD      R0,SP,#+24
   \   000001A4   808D               LDRH     R0,[R0, #+44]
   \   000001A6   8542               CMP      R5,R0
   \   000001A8   3CDA               BGE      ??elfload_29
   \   000001AA   6846               MOV      R0,SP
   \   000001AC   01B4               PUSH     {R0}
   \   000001AE   0298               LDR      R0,[SP, #+8]
   \   000001B0   01AB               ADD      R3,SP,#+4
   \   000001B2   4168               LDR      R1,[R0, #+4]
   \   000001B4   0022               MOVS     R2,#+0
   \   000001B6   2000               MOVS     R0,R4
   \   000001B8   0FDF               SVC      +15
   \   000001BA   0299               LDR      R1,[SP, #+8]
   \   000001BC   4968               LDR      R1,[R1, #+4]
   \   000001BE   01B0               ADD      SP,SP,#+4
   \   000001C0   8842               CMP      R0,R1
   \   000001C2   97D0               BEQ      ??elfload_16
   \   000001C4   6946               MOV      R1,SP
   \   000001C6   2000               MOVS     R0,R4
   \   000001C8   0DDF               SVC      +13
   \   000001CA   3000               MOVS     R0,R6
   \   000001CC   15DF               SVC      +21
   \   000001CE   0520               MOVS     R0,#+5
   \   000001D0   2EE7               B.N      ??elfload_3
   \                     ??elfload_30:
   \   000001D2   0499               LDR      R1,[SP, #+16]
   \   000001D4   1368               LDR      R3,[R2, #+0]
   \   000001D6   7118               ADDS     R1,R6,R1
   \   000001D8   CA58               LDR      R2,[R1, R3]
   \   000001DA   9C46               MOV      R12,R3
   \   000001DC   9319               ADDS     R3,R2,R6
   \   000001DE   029A               LDR      R2,[SP, #+8]
   \   000001E0   9A1A               SUBS     R2,R3,R2
   \   000001E2   6346               MOV      R3,R12
   \   000001E4   CA50               STR      R2,[R1, R3]
   \                     ??elfload_31:
   \   000001E6   401C               ADDS     R0,R0,#+1
   \                     ??elfload_27:
   \   000001E8   039A               LDR      R2,[SP, #+12]
   \   000001EA   C100               LSLS     R1,R0,#+3
   \   000001EC   9142               CMP      R1,R2
   \   000001EE   CFD2               BCS      ??elfload_28
   \   000001F0   749A               LDR      R2,[SP, #+464]
   \   000001F2   BA18               ADDS     R2,R7,R2
   \   000001F4   5218               ADDS     R2,R2,R1
   \   000001F6   5168               LDR      R1,[R2, #+4]
   \   000001F8   0906               LSLS     R1,R1,#+24
   \   000001FA   090E               LSRS     R1,R1,#+24
   \   000001FC   FD29               CMP      R1,#+253
   \   000001FE   E8D0               BEQ      ??elfload_30
   \   00000200   FF29               CMP      R1,#+255
   \   00000202   F0D0               BEQ      ??elfload_31
   \   00000204   6946               MOV      R1,SP
   \   00000206   2000               MOVS     R0,R4
   \   00000208   0DDF               SVC      +13
   \   0000020A   3000               MOVS     R0,R6
   \   0000020C   15DF               SVC      +21
   \   0000020E   3800               MOVS     R0,R7
   \   00000210   15DF               SVC      +21
   \   00000212   0C20               MOVS     R0,#+12
   \   00000214   8AE7               B.N      ??elfload_21
    438                break;
    439              default:	//неизвестный тип програмного сегмента
    440          #ifndef wintel
    441                fclose(fin, &iError);
   \                     ??elfload_19:
   \   00000216   6946               MOV      R1,SP
   \   00000218   2000               MOVS     R0,R4
   \   0000021A   0DDF               SVC      +13
    442          #endif
    443                mfree(base);
   \   0000021C   3000               MOVS     R0,R6
   \   0000021E   15DF               SVC      +21
    444                return -12;
   \   00000220   0B20               MOVS     R0,#+11
   \   00000222   05E7               B.N      ??elfload_3
    445              }
    446            }
    447          #ifndef wintel
    448            fclose(fin, &iError);
   \                     ??elfload_29:
   \   00000224   6946               MOV      R1,SP
   \   00000226   2000               MOVS     R0,R4
   \   00000228   0DDF               SVC      +13
    449            {
    450              extern __arm void ExecuteIMB(void);
    451              ExecuteIMB();	
   \   0000022A   ........           _BLF     ExecuteIMB,??ExecuteIMB??rT
    452            }
    453            ((TElfEntry *)(base+ehdr.e_entry-minadr))(filename,param1,param2,param3);
   \   0000022E   049C               LDR      R4,[SP, #+16]
   \   00000230   0C9D               LDR      R5,[SP, #+48]
   \   00000232   7F9B               LDR      R3,[SP, #+508]
   \   00000234   7E9A               LDR      R2,[SP, #+504]
   \   00000236   7D99               LDR      R1,[SP, #+500]
   \   00000238   7C98               LDR      R0,[SP, #+496]
   \   0000023A   7519               ADDS     R5,R6,R5
   \   0000023C   2C19               ADDS     R4,R5,R4
   \   0000023E   A047               BLX      R4
    454            //	mfree(base);
    455            return 0;
   \   00000240   0020               MOVS     R0,#+0
   \                     ??elfload_1:
   \   00000242   7FB0               ADD      SP,SP,#+508
   \   00000244   01B0               ADD      SP,SP,#+4
   \   00000246   F0BD               POP      {R4-R7,PC}       ;; return
   \                     ??elfload_4:
   \   00000248   7F454C46           DC32     0x464c457f
    456          #endif
    457          #ifdef wintel
    458            FILE fout;
    459            char foutbuff[10];
    460            sprintf(foutbuff,"0x%08x",base);
    461            if ((fin=fopen(foutbuff,"wb"))==NULL) return -1000;
    462            if (fwrite(base,maxadr+maxadrsize-minadr,1,fin)!=1) return -1001;
    463            return 0;
    464          #endif
    465          }
    466          
    467          #ifdef wintel
    468          int main(int argc, char* argv[]){
    469            cout << elfload(argv[1],0,0,0);
    470            return 1;
    471          }
    472          #endif
    473          
    474          #ifndef wintel

   \                                 In segment CODE, align 4, keep-with-next
    475          void elfloader_onload(WSHDR *filename){
   \                     elfloader_onload:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   A0B0               SUB      SP,SP,#+128
    476            char fn[128];
    477            ws_2str(filename,fn,126);
   \   00000004   7E22               MOVS     R2,#+126
   \   00000006   6946               MOV      R1,SP
   \   00000008   A3DF               SVC      +163
    478            elfload(fn,0,0,0);
   \   0000000A   0023               MOVS     R3,#+0
   \   0000000C   0022               MOVS     R2,#+0
   \   0000000E   1100               MOVS     R1,R2
   \   00000010   6846               MOV      R0,SP
   \   00000012   ........           BL       elfload
    479          }
   \   00000016   20B0               ADD      SP,SP,#+128
   \   00000018   00BD               POP      {PC}             ;; return
    480          
    481          //=======================================================================
    482          //
    483          //=======================================================================
    484          extern void(*OldOnClose)(void *);
    485          extern void(*OldOnCreate)(void *);
    486          extern void(*OldShowMsg)(int, int);
    487          
    488          //-----------------------------------------------------------------------
    489          
    490          #define HELPER_CEPID 0x4339
    491          #define MSG_HELPER_RUN 0x0001
    492          

   \                                 In segment HELPER_PROC, align 4, keep-with-next
    493          __arm void proc_HELPER(void) @ "HELPER_PROC"
    494          {
   \                     proc_HELPER:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   14D04DE2           SUB      SP,SP,#+20
    495            GBS_MSG msg;
    496            if (GBS_RecActDstMessage(&msg))
   \   00000008   0D00A0E1           MOV      R0,SP
   \   0000000C   530100EF           SWI      +339
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0800000A           BEQ      ??proc_HELPER_0
    497            {
    498              if (msg.msg==MSG_HELPER_RUN)
   \   00000018   04009DE5           LDR      R0,[SP, #+4]
   \   0000001C   010050E3           CMP      R0,#+1
   \   00000020   0500001A           BNE      ??proc_HELPER_0
    499              {
    500                if (msg.data0)
   \   00000024   0C209DE5           LDR      R2,[SP, #+12]
   \   00000028   000052E3           CMP      R2,#+0
   \   0000002C   0200000A           BEQ      ??proc_HELPER_0
    501                {
    502          	((void (*)(int, void *))(msg.data0))(msg.submess,msg.data1);
   \   00000030   10109DE5           LDR      R1,[SP, #+16]
   \   00000034   08009DE5           LDR      R0,[SP, #+8]
   \   00000038   32FF2FE1           BLX      R2
    503                }
    504              }
    505            }
    506          }
   \                     ??proc_HELPER_0:
   \   0000003C   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   00000040   0080BDE8           POP      {PC}             ;; return
    507          

   \                                 In segment HELPER_PROC, align 4, keep-with-next
    508          __arm void CreateHELPER_PROC(void) @ "HELPER_PROC"
    509          {
   \                     CreateHELPER_PROC:
   \   00000000   00402DE9           PUSH     {LR}
    510            static const char name[] @ "HELPER_PROC_DATA" ="HELPER";
    511            CreateGBSproc(HELPER_CEPID, name, proc_HELPER, 0x80, 0);
   \   00000004   20209FE5           LDR      R2,??CreateHELPER_PROC_0  ;; proc_HELPER
   \   00000008   20109FE5           LDR      R1,??CreateHELPER_PROC_0+0x4  ;; ??name
   \   0000000C   0000A0E3           MOV      R0,#+0
   \   00000010   01002DE9           PUSH     {R0}
   \   00000014   8030A0E3           MOV      R3,#+128
   \   00000018   3900A0E3           MOV      R0,#+57
   \   0000001C   430C80E3           ORR      R0,R0,#0x4300
   \   00000020   050100EF           SWI      +261
    512          }
   \   00000024   04D08DE2           ADD      SP,SP,#+4
   \   00000028   0080BDE8           POP      {PC}             ;; return
   \                     ??CreateHELPER_PROC_0:
   \   0000002C   ........           DC32     proc_HELPER
   \   00000030   ........           DC32     ??name

   \                                 In segment HELPER_PROC_DATA, align 4, align-sorted
   \                     ??name:
   \   00000000   48454C504552       DC8 "HELPER"
   \              00          
   \   00000007   00                 DC8 0
    513          

   \                                 In segment HELPER_PROC, align 4, keep-with-next
    514          __arm void REDRAW_impl(void) @"HELPER_PROC"
    515          {
   \                     REDRAW_impl:
   \   00000000   00402DE9           PUSH     {LR}
    516            LockSched();
   \   00000004   460100EF           SWI      +326
    517          #ifdef NEWSGOLD
    518            PendedRedrawGUI();
   \   00000008   410100EF           SWI      +321
    519          #else
    520            PendedRedrawGUI();
    521            GBS_SendMessage(MMI_CEPID,0x91);
    522          #endif
    523            UnlockSched();
   \   0000000C   470100EF           SWI      +327
   \   00000010   0080BDE8           POP      {PC}             ;; return
    524          }
    525          

   \                                 In segment HELPER_PROC, align 4, keep-with-next
    526          __arm void SUBPROC_impl(void *f, int p2, void *p1) @ "HELPER_PROC"
    527          {
   \                     SUBPROC_impl:
   \   00000000   00402DE9           PUSH     {LR}
    528            GBS_SendMessage(HELPER_CEPID,MSG_HELPER_RUN,p2,f,p1);
   \   00000004   04002DE9           PUSH     {R2}
   \   00000008   0030A0E1           MOV      R3,R0
   \   0000000C   3900A0E3           MOV      R0,#+57
   \   00000010   430C80E3           ORR      R0,R0,#0x4300
   \   00000014   0120A0E1           MOV      R2,R1
   \   00000018   0110A0E3           MOV      R1,#+1
   \   0000001C   000100EF           SWI      +256
    529          }
   \   00000020   04D08DE2           ADD      SP,SP,#+4
   \   00000024   0080BDE8           POP      {PC}             ;; return
    530          

   \                                 In segment CODE, align 4, keep-with-next
    531          __arm void MyIDLECSMonClose(void *data)
    532          {
   \                     MyIDLECSMonClose:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    533            KillGBSproc(HELPER_CEPID);
   \   00000008   3900A0E3           MOV      R0,#+57
   \   0000000C   430C80E3           ORR      R0,R0,#0x4300
   \   00000010   540100EF           SWI      +340
    534            OldOnClose(data);
   \   00000014   10109FE5           LDR      R1,??MyIDLECSMonClose_0  ;; OldOnClose
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   001091E5           LDR      R1,[R1, #+0]
   \   00000020   31FF2FE1           BLX      R1
    535            asm("NOP\n");
   \   00000024   0000A0E1           NOP
   \   00000028   1080BDE8           POP      {R4,PC}          ;; return
   \                     ??MyIDLECSMonClose_0:
   \   0000002C   ........           DC32     OldOnClose
    536          }
    537          

   \                                 In segment CODE, align 4, keep-with-next
    538          __arm void LoadDaemons(int dummy, char *path)
    539          {
   \                     LoadDaemons:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   48D04DE2           SUB      SP,SP,#+72
   \   00000008   40DE4DE2           SUB      SP,SP,#+1024
   \   0000000C   0140A0E1           MOV      R4,R1
    540            DIR_ENTRY de;
    541            unsigned int err;
    542            char name[256];
    543            strcpy(name,path);
   \   00000010   D20F8DE2           ADD      R0,SP,#+840
   \   00000014   1A0000EF           SWI      +26
    544            strcat(name,"*.elf");
   \   00000018   74109FE5           LDR      R1,??LoadDaemons_0  ;; `?<Constant "*.elf">`
   \   0000001C   D20F8DE2           ADD      R0,SP,#+840
   \   00000020   170000EF           SWI      +23
    545            if (FindFirstFile(&de,name,&err))
   \   00000024   0D20A0E1           MOV      R2,SP
   \   00000028   D21F8DE2           ADD      R1,SP,#+840
   \   0000002C   04008DE2           ADD      R0,SP,#+4
   \   00000030   6B0000EF           SWI      +107
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   0F00000A           BEQ      ??LoadDaemons_1
    546            {
    547              do
    548              {
    549                strcpy(name,path);
   \                     ??LoadDaemons_2:
   \   0000003C   0410A0E1           MOV      R1,R4
   \   00000040   D20F8DE2           ADD      R0,SP,#+840
   \   00000044   1A0000EF           SWI      +26
    550                strcat(name,de.file_name);
   \   00000048   B9108DE2           ADD      R1,SP,#+185
   \   0000004C   D20F8DE2           ADD      R0,SP,#+840
   \   00000050   170000EF           SWI      +23
    551                elfload(name,0,0,0);
   \   00000054   0030A0E3           MOV      R3,#+0
   \   00000058   0020A0E3           MOV      R2,#+0
   \   0000005C   0210A0E1           MOV      R1,R2
   \   00000060   D20F8DE2           ADD      R0,SP,#+840
   \   00000064   ........           BLX      elfload
    552              }
    553              while(FindNextFile(&de,&err));
   \   00000068   0D10A0E1           MOV      R1,SP
   \   0000006C   04008DE2           ADD      R0,SP,#+4
   \   00000070   6C0000EF           SWI      +108
   \   00000074   000050E3           CMP      R0,#+0
   \   00000078   EFFFFF1A           BNE      ??LoadDaemons_2
    554            }
    555            FindClose(&de,&err);
   \                     ??LoadDaemons_1:
   \   0000007C   0D10A0E1           MOV      R1,SP
   \   00000080   04008DE2           ADD      R0,SP,#+4
   \   00000084   6D0000EF           SWI      +109
    556          }
   \   00000088   48D08DE2           ADD      SP,SP,#+72
   \   0000008C   40DE8DE2           ADD      SP,SP,#+1024
   \   00000090   1080BDE8           POP      {R4,PC}          ;; return
   \                     ??LoadDaemons_0:
   \   00000094   ........           DC32     `?<Constant "*.elf">`
    557          

   \                                 In segment CODE, align 4, keep-with-next
    558          __arm void MyIDLECSMonCreate(void *data)
    559          {
   \                     MyIDLECSMonCreate:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   34509FE5           LDR      R5,??MyIDLECSMonCreate_0  ;; `?<Constant "4:\\\\ZBin\\\\Daemons\\\\">`
   \   00000008   0040A0E1           MOV      R4,R0
    560            static const int smallicons[2]={0x3f5,0};
    561            static const int bigicons[2]={0x439,0};
    562            static const REGEXPLEXT elf_reg=
    563            {
    564              "elf",
    565              0x55,
    566              //   0x59C1200,
    567              0x59D43FF,
    568          //    0x5431F04,
    569              smallicons,
    570              bigicons,
    571              //   0xBB,
    572              0x109,
    573              0x197,
    574              //   0x7FFFC112,
    575              0x7FFFC0FB,
    576              (void *)elfloader_onload,
    577              0
    578          
    579            };
    580            CreateHELPER_PROC();
   \   0000000C   ........           _BLF     CreateHELPER_PROC,??CreateHELPER_PROC??rA
    581            RegExplorerExt(&elf_reg);
   \   00000010   140085E2           ADD      R0,R5,#+20
   \   00000014   8C0000EF           SWI      +140
    582            SUBPROC((void *)LoadDaemons,0,"4:\\ZBin\\Daemons\\");
   \   00000018   24009FE5           LDR      R0,??MyIDLECSMonCreate_0+0x4  ;; LoadDaemons
   \   0000001C   0520A0E1           MOV      R2,R5
   \   00000020   0010A0E3           MOV      R1,#+0
   \   00000024   710100EF           SWI      +369
    583            OldOnCreate(data);
   \   00000028   18109FE5           LDR      R1,??MyIDLECSMonCreate_0+0x8  ;; OldOnCreate
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   001091E5           LDR      R1,[R1, #+0]
   \   00000034   31FF2FE1           BLX      R1
    584            asm("NOP\n");
   \   00000038   0000A0E1           NOP
   \   0000003C   3080BDE8           POP      {R4,R5,PC}       ;; return
   \                     ??MyIDLECSMonCreate_0:
   \   00000040   ........           DC32     `?<Constant "4:\\\\ZBin\\\\Daemons\\\\">`
   \   00000044   ........           DC32     LoadDaemons
   \   00000048   ........           DC32     OldOnCreate
    585          }

   \                                 In segment DATA_C, align 4, align-sorted
   \                     ??smallicons:
   \   00000000   F50300000000       DC32 1013, 0
   \              0000        

   \                                 In segment DATA_C, align 4, align-sorted
   \                     ??bigicons:
   \   00000000   390400000000       DC32 1081, 0
   \              0000        

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "4:\\\\ZBin\\\\Daemons\\\\">`:
   \   00000000   343A5C5A4269       DC8 "4:\\ZBin\\Daemons\\"
   \              6E5C4461656D
   \              6F6E735C00  
   \   00000011   000000             DC8 0, 0, 0
   \   00000014   ........5500       DC32 `?<Constant "elf">`, 85, 94192639, ??smallicons, ??bigicons, 265
   \              0000FF439D05
   \              ............
   \              ....09010000
   \   0000002C   97010000FBC0       DC32 407, 2147467515, elfloader_onload, 0
   \              FF7F........
   \              00000000    
    586          

   \                                 In segment CODE, align 4, keep-with-next
    587          __arm void ESI(WSHDR *ws, int dummy, char *s)
    588          {
   \                     ESI:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    589            int c;
    590            CutWSTR(ws,0);
   \   00000004   0010A0E3           MOV      R1,#+0
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0250A0E1           MOV      R5,R2
   \   00000010   260100EF           SWI      +294
   \   00000014   030000EA           B        ??ESI_0
    591            while((c=*s++))
    592            {
    593              if (c>=0xC0) c+=0x350;
   \                     ??ESI_1:
   \   00000018   C00051E3           CMP      R1,#+192
   \   0000001C   D41F81A2           ADDGE    R1,R1,#+848
    594              wsAppendChar(ws,c);
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   1C0000EF           SWI      +28
    595            }
   \                     ??ESI_0:
   \   00000028   ........           LDRB     R1,[R5], #+1
   \   0000002C   000051E3           CMP      R1,#+0
   \   00000030   F8FFFF1A           BNE      ??ESI_1
    596          }
   \   00000034   3080BDE8           POP      {R4,R5,PC}       ;; return
    597          

   \                                 In segment CODE, align 4, keep-with-next
    598          int toupper(int c)
    599          {
   \                     toupper:
   \   00000000   00B5               PUSH     {LR}
    600            if ((c>='a')&&(c<='z')) c+='A'-'a';
   \   00000002   6128               CMP      R0,#+97
   \   00000004   02DB               BLT      ??toupper_0
   \   00000006   7B28               CMP      R0,#+123
   \   00000008   00DA               BGE      ??toupper_0
   \   0000000A   2038               SUBS     R0,R0,#+32
    601            return(c);
   \                     ??toupper_0:
   \   0000000C   00BD               POP      {PC}             ;; return
    602          }
    603          

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "Nothing to run!">`:
   \   00000000   4E6F7468696E       DC8 "Nothing to run!"
   \              6720746F2072
   \              756E2100    
   \   00000010   43616E277420       DC8 "Can't run ELF!"
   \              72756E20454C
   \              462100      
   \   0000001F   00                 DC8 0
   \   00000020   456C66732E65       DC8 "Elfs.ext not found!"
   \              7874206E6F74
   \              20666F756E64
   \              2100        
   \   00000034   343A5C5A4269       DC8 "4:\\ZBin\\etc\\extension.cfg"
   \              6E5C6574635C
   \              657874656E73
   \              696F6E2E6366
   \              6700        
   \   0000004E   0000               DC8 0, 0
    604          static const char extfile[]="4:\\ZBin\\etc\\extension.cfg";
    605          

   \                                 In segment CODE, align 4, keep-with-next
    606          __arm int DoUnknownFileType(WSHDR *filename)
    607          {
   \                     DoUnknownFileType:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   62DF4DE2           SUB      SP,SP,#+392
    608            char fn[128];
    609            char s[256];
    610            int f;
    611            unsigned int i;
    612            unsigned int mi;
    613            int c;
    614            unsigned int sm=0;
   \   00000008   0040A0E3           MOV      R4,#+0
   \   0000000C   0060A0E3           MOV      R6,#+0
    615            char *execname=0;
   \   00000010   0450A0E1           MOV      R5,R4
    616            char *fname;
    617            unsigned int ul;
    618          
    619            ws_2str(filename,fn,126);
   \   00000014   7E20A0E3           MOV      R2,#+126
   \   00000018   421F8DE2           ADD      R1,SP,#+264
   \   0000001C   A30000EF           SWI      +163
    620          
    621            i=strlen(fn);
   \   00000020   420F8DE2           ADD      R0,SP,#+264
   \   00000024   1B0000EF           SWI      +27
   \   00000028   0080B0E1           MOVS     R8,R0
   \   0000002C   0200001A           BNE      ??DoUnknownFileType_0
    622            if (!i) return 0;
   \                     ??DoUnknownFileType_1:
   \   00000030   0000A0E3           MOV      R0,#+0
   \                     ??DoUnknownFileType_2:
   \   00000034   62DF8DE2           ADD      SP,SP,#+392      ;; stack cleaning
   \   00000038   F08FBDE8           POP      {R4-R11,PC}      ;; return
    623            if (i>127) return 0;
   \                     ??DoUnknownFileType_0:
   \   0000003C   800058E3           CMP      R8,#+128
   \   00000040   FAFFFF2A           BCS      ??DoUnknownFileType_1
    624          
    625            fname=fn+i; //”казатель на посл. байт
   \   00000044   420F8DE2           ADD      R0,SP,#+264
   \   00000048   007088E0           ADD      R7,R8,R0
   \   0000004C   010047E2           SUB      R0,R7,#+1
   \   00000050   000000EA           B        ??DoUnknownFileType_3
    626            while(fname[-1]!='.')
    627            {
    628              i--;
    629              if (i==0) {
    630                fname="";
    631                break;
    632              }
    633              fname--;
   \                     ??DoUnknownFileType_4:
   \   00000054   017047E2           SUB      R7,R7,#+1
   \                     ??DoUnknownFileType_3:
   \   00000058   ........           LDRB     R1,[R0], #-1
   \   0000005C   2E0051E3           CMP      R1,#+46
   \   00000060   0200000A           BEQ      ??DoUnknownFileType_5
   \   00000064   018058E2           SUBS     R8,R8,#+1
   \   00000068   F9FFFF1A           BNE      ??DoUnknownFileType_4
   \   0000006C   6D7F8FE2           ADR      R7,??DoUnknownFileType_6  ;; ""
   \                     ??DoUnknownFileType_5:
   \   00000070   B4019FE5           LDR      R0,??DoUnknownFileType_6+0x4  ;; `?<Constant "Nothing to run!">` + 52
   \   00000074   0D30A0E1           MOV      R3,SP
   \   00000078   0020A0E3           MOV      R2,#+0
   \   0000007C   0210A0E1           MOV      R1,R2
    634            }
    635            //“еперь fname указывает на расширение
    636            if ((f=fopen(extfile,A_ReadOnly,0,&ul))!=-1)
   \   00000080   0A0000EF           SWI      +10
   \   00000084   04008DE5           STR      R0,[SP, #+4]
   \   00000088   010070E3           CMN      R0,#+1
   \   0000008C   6300000A           BEQ      ??DoUnknownFileType_7
    637            {
    638              i=fread(f,s,128,&ul);
   \   00000090   0D30A0E1           MOV      R3,SP
   \   00000094   8020A0E3           MOV      R2,#+128
   \   00000098   08108DE2           ADD      R1,SP,#+8
   \   0000009C   0B0000EF           SWI      +11
   \   000000A0   0080A0E1           MOV      R8,R0
    639              mi=128;
   \   000000A4   8090A0E3           MOV      R9,#+128
    640              if (i<128)
   \   000000A8   800058E3           CMP      R8,#+128
   \   000000AC   1200002A           BCS      ??DoUnknownFileType_8
    641                s[i]=0;
   \   000000B0   08008DE2           ADD      R0,SP,#+8
   \   000000B4   0040C8E7           STRB     R4,[R8, +R0]
   \   000000B8   1B0000EA           B        ??DoUnknownFileType_9
    642              else
    643              {
    644              L1:
    645                i=fread(f,s+128,128,&ul);
    646                if (i<128)
    647                {
    648          	(s+128)[i]=0;
    649          	mi=256;
    650                }
    651              }
    652              i=0;
    653              for(;;)
    654              {
    655                if (i==mi)
    656                {
    657          	memcpy(s,s+128,128);
    658          	goto L1;
    659                }
    660                c=s[i++];
    661                if (!c) break; // онец файла
    662                switch(sm)
    663                {
    664                case 0xFFFF:
    665          	//∆дем окончани€ строки
    666          	if (c==':')
    667          	{
    668                    execname=s+i; //ѕоследний файл - универсальный
    669                    sm--; //“олько первый вход
    670          	}
    671                case 0xFFFE:
    672          	if ((c==0x0D)||(c==0x0A)) sm=0; break;
    673                default:
    674          	if ((c==0x0D)||(c==0x0A))
    675          	{
    676                    //Ќеожиданный конец строки
    677                    sm=0;
    678                    break;
    679          	}
    680          	if ((c==':')&&(!fname[sm]))
    681          	{
    682                    //ѕолное совпадение
    683                    execname=s+i;
    684                    goto L_EOF;
    685          	}
    686          	if (toupper(c)==toupper(fname[sm])) sm++; else sm=0xFFFF;
    687          	break;
    688                }
    689              }
    690              if (!execname)
   \                     ??DoUnknownFileType_10:
   \   000000BC   000055E3           CMP      R5,#+0
   \   000000C0   3900001A           BNE      ??DoUnknownFileType_11
    691              {
    692                ShowMSG(1,(int)"Nothing to run!");
   \   000000C4   64119FE5           LDR      R1,??DoUnknownFileType_6+0x8  ;; `?<Constant "Nothing to run!">`
   \                     ??DoUnknownFileType_12:
   \   000000C8   0100A0E3           MOV      R0,#+1
   \   000000CC   480100EF           SWI      +328
   \   000000D0   D6FFFFEA           B        ??DoUnknownFileType_1
    693                return 0; //Ќет сопоставлений
    694              }
   \                     ??DoUnknownFileType_13:
   \   000000D4   3A0050E3           CMP      R0,#+58
   \   000000D8   2500001A           BNE      ??DoUnknownFileType_14
   \   000000DC   0150A0E1           MOV      R5,R1
   \   000000E0   016046E2           SUB      R6,R6,#+1
   \                     ??DoUnknownFileType_15:
   \   000000E4   090058E1           CMP      R8,R9
   \   000000E8   1200001A           BNE      ??DoUnknownFileType_16
   \                     ??DoUnknownFileType_17:
   \   000000EC   8020A0E3           MOV      R2,#+128
   \   000000F0   88108DE2           ADD      R1,SP,#+136
   \   000000F4   08008DE2           ADD      R0,SP,#+8
   \   000000F8   1E0100EF           SWI      +286
   \                     ??DoUnknownFileType_8:
   \   000000FC   04009DE5           LDR      R0,[SP, #+4]
   \   00000100   0D30A0E1           MOV      R3,SP
   \   00000104   8020A0E3           MOV      R2,#+128
   \   00000108   88108DE2           ADD      R1,SP,#+136
   \   0000010C   0B0000EF           SWI      +11
   \   00000110   0080A0E1           MOV      R8,R0
   \   00000114   800058E3           CMP      R8,#+128
   \   00000118   0300002A           BCS      ??DoUnknownFileType_9
   \   0000011C   08008DE2           ADD      R0,SP,#+8
   \   00000120   000088E0           ADD      R0,R8,R0
   \   00000124   8040C0E5           STRB     R4,[R0, #+128]
   \   00000128   409FA0E3           MOV      R9,#+256
   \                     ??DoUnknownFileType_9:
   \   0000012C   0080A0E3           MOV      R8,#+0
   \   00000130   000059E3           CMP      R9,#+0
   \   00000134   ECFFFF0A           BEQ      ??DoUnknownFileType_17
   \                     ??DoUnknownFileType_16:
   \   00000138   08008DE2           ADD      R0,SP,#+8
   \   0000013C   0000D8E7           LDRB     R0,[R8, +R0]
   \   00000140   018088E2           ADD      R8,R8,#+1
   \   00000144   000050E3           CMP      R0,#+0
   \   00000148   DBFFFF0A           BEQ      ??DoUnknownFileType_10
   \   0000014C   08108DE2           ADD      R1,SP,#+8
   \   00000150   011088E0           ADD      R1,R8,R1
   \   00000154   FE30A0E3           MOV      R3,#+254
   \   00000158   FF3C83E3           ORR      R3,R3,#0xFF00
   \   0000015C   030056E1           CMP      R6,R3
   \   00000160   0300000A           BEQ      ??DoUnknownFileType_14
   \   00000164   013083E3           ORR      R3,R3,#0x1
   \   00000168   030056E1           CMP      R6,R3
   \   0000016C   D8FFFF0A           BEQ      ??DoUnknownFileType_13
   \   00000170   040000EA           B        ??DoUnknownFileType_18
   \                     ??DoUnknownFileType_14:
   \   00000174   0D0050E3           CMP      R0,#+13
   \   00000178   0A005013           CMPNE    R0,#+10
   \   0000017C   D8FFFF1A           BNE      ??DoUnknownFileType_15
   \                     ??DoUnknownFileType_19:
   \   00000180   0060A0E3           MOV      R6,#+0
   \   00000184   D6FFFFEA           B        ??DoUnknownFileType_15
   \                     ??DoUnknownFileType_18:
   \   00000188   0D0050E3           CMP      R0,#+13
   \   0000018C   0A005013           CMPNE    R0,#+10
   \   00000190   FAFFFF0A           BEQ      ??DoUnknownFileType_19
   \   00000194   07A086E0           ADD      R10,R6,R7
   \   00000198   3A0050E3           CMP      R0,#+58
   \   0000019C   0020DA05           LDRBEQ   R2,[R10, #+0]
   \   000001A0   00005203           CMPEQ    R2,#+0
   \   000001A4   0500001A           BNE      ??DoUnknownFileType_20
   \   000001A8   0150A0E1           MOV      R5,R1
    695            L_EOF:
    696              fclose(f,&ul);
   \                     ??DoUnknownFileType_11:
   \   000001AC   04009DE5           LDR      R0,[SP, #+4]
   \   000001B0   0D10A0E1           MOV      R1,SP
   \   000001B4   0D0000EF           SWI      +13
    697              i=0;
   \   000001B8   0080A0E3           MOV      R8,#+0
   \   000001BC   090000EA           B        ??DoUnknownFileType_21
   \                     ??DoUnknownFileType_20:
   \   000001C0   ........           BLX      toupper
   \   000001C4   00B0A0E1           MOV      R11,R0
   \   000001C8   0000DAE5           LDRB     R0,[R10, #+0]
   \   000001CC   ........           BLX      toupper
   \   000001D0   00005BE1           CMP      R11,R0
   \   000001D4   FF60A013           MOVNE    R6,#+255
   \   000001D8   FF6C8613           ORRNE    R6,R6,#0xFF00
   \   000001DC   01608602           ADDEQ    R6,R6,#+1
   \   000001E0   BFFFFFEA           B        ??DoUnknownFileType_15
    698              while(execname[i]>31) i++;
   \                     ??DoUnknownFileType_22:
   \   000001E4   018088E2           ADD      R8,R8,#+1
   \                     ??DoUnknownFileType_21:
   \   000001E8   050088E0           ADD      R0,R8,R5
   \   000001EC   0010D0E5           LDRB     R1,[R0, #+0]
   \   000001F0   200051E3           CMP      R1,#+32
   \   000001F4   FAFFFF2A           BCS      ??DoUnknownFileType_22
    699              execname[i]=0;
   \   000001F8   0040C0E5           STRB     R4,[R0, #+0]
    700              if (elfload(execname,fn,0,0))
   \   000001FC   0030A0E3           MOV      R3,#+0
   \   00000200   0320A0E1           MOV      R2,R3
   \   00000204   421F8DE2           ADD      R1,SP,#+264
   \   00000208   0500A0E1           MOV      R0,R5
   \   0000020C   ........           BLX      elfload
   \   00000210   000050E3           CMP      R0,#+0
   \   00000214   86FFFF0A           BEQ      ??DoUnknownFileType_2
    701              {
    702                ShowMSG(1,(int)"Can't run ELF!");
   \   00000218   14109FE5           LDR      R1,??DoUnknownFileType_6+0xC  ;; `?<Constant "Nothing to run!">` + 16
   \                     ??DoUnknownFileType_23:
   \   0000021C   A9FFFFEA           B        ??DoUnknownFileType_12
    703              }
    704            }
    705            else
    706            {
    707              ShowMSG(1,(int)"Elfs.ext not found!");
   \                     ??DoUnknownFileType_7:
   \   00000220   10109FE5           LDR      R1,??DoUnknownFileType_6+0x10  ;; `?<Constant "Nothing to run!">` + 32
   \   00000224   A7FFFFEA           B        ??DoUnknownFileType_12
   \                     ??DoUnknownFileType_6:
   \   00000228   00000000           DC8      "",+0,+0,+0
   \   0000022C   ........           DC32     `?<Constant "Nothing to run!">` + 52
   \   00000230   ........           DC32     `?<Constant "Nothing to run!">`
   \   00000234   ........           DC32     `?<Constant "Nothing to run!">` + 16
   \   00000238   ........           DC32     `?<Constant "Nothing to run!">` + 32
    708            }
    709            return 0;
    710          }
    711          

   \                                 In segment CODE, align 4, keep-with-next
    712          __thumb MyShowMSG(int p1, int p2)
    713          {
    714            if (p2!=(0x1DCC+5))
   \                     MyShowMSG:
   \   00000000   054A               LDR      R2,??MyShowMSG_0  ;; 0x1dd1
   \   00000002   00B5               PUSH     {LR}
   \   00000004   9142               CMP      R1,R2
   \   00000006   03D0               BEQ      ??MyShowMSG_1
    715            {
    716              OldShowMsg(p1,p2);
   \   00000008   044A               LDR      R2,??MyShowMSG_0+0x4  ;; OldShowMsg
   \   0000000A   1268               LDR      R2,[R2, #+0]
   \   0000000C   9047               BLX      R2
   \   0000000E   00BD               POP      {PC}
    717              return;
    718            }
    719            asm("MOVS R0,R6\n");
   \                     ??MyShowMSG_1:
   \   00000010   3000               MOVS R0,R6
    720            DoUnknownFileType((WSHDR *)p1);
   \   00000012   ........           BLX      DoUnknownFileType
   \   00000016   00BD               POP      {PC}             ;; return
   \                     ??MyShowMSG_0:
   \   00000018   D11D0000           DC32     0x1dd1
   \   0000001C   ........           DC32     OldShowMsg
    721          }
    722          
    723          
    724          //ѕатчи
    725          #pragma diag_suppress=Pe177

   \                                 In segment PATCH_ONCREATE, align 4, align-sorted, root
   \   00000000   ........           DC32 MyIDLECSMonCreate
    726          __root static const int NEW_ONCREATE @ "PATCH_ONCREATE" = (int)MyIDLECSMonCreate;
    727          

   \                                 In segment PATCH_ONCLOSE, align 4, align-sorted, root
   \   00000000   ........           DC32 MyIDLECSMonClose
    728          __root static const int NEW_ONCLOSE @ "PATCH_ONCLOSE" = (int)MyIDLECSMonClose;
    729          

   \                                 In segment PATCH_SHOWMSG_BLF, align 4, align-sorted, root
   \   00000000   ........           DC32 MyShowMSG
    730          __root static const int NEW_SHOWMSG @ "PATCH_SHOWMSG_BLF" = (int)MyShowMSG;
    731          

   \                                 In segment PATCH_TXT_EXT, align 4, align-sorted, root
   \   00000000   ........           DC32 DoUnknownFileType
    732          __root static const int NEW_TXTEXT @ "PATCH_TXT_EXT" = (int)DoUnknownFileType;
    733          

   \                                 In segment SWILIB_FUNC171, align 4, align-sorted, root
   \   00000000   ........           DC32 SUBPROC_impl
    734          __root static const int SWILIB_FUNC171 @ "SWILIB_FUNC171" = (int)SUBPROC_impl;
    735          

   \                                 In segment SWILIB_FUNC172, align 4, align-sorted, root
   \   00000000   ........           DC32 REDRAW_impl

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "*.elf">`:
   \   00000000   2A2E656C6600       DC8 "*.elf"
   \   00000006   0000               DC8 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "elf">`:
   \   00000000   656C6600           DC8 "elf"

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   00                 DC8 ""
    736          __root static const int SWILIB_FUNC172 @ "SWILIB_FUNC172" = (int)REDRAW_impl;
    737          #pragma diag_default=Pe177
    738          #endif
    739          

   Maximum stack usage in bytes:

     Function          CSTACK
     --------          ------
     CreateHELPER_PROC     8
     DoUnknownFileType   428
     ESI                  12
     LoadDaemons        1104
     MyIDLECSMonClose      8
     MyIDLECSMonCreate    12
     MyShowMSG             4
     REDRAW_impl           4
     SUBPROC_impl          8
     elfload             536
     elfloader_onload    132
     proc_HELPER          24
     toupper               4
     zeromem_a             4


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     zeromem_a                        12
     elfload                         588
     elfloader_onload                 26
     proc_HELPER                      68
     CreateHELPER_PROC                52
     name                              8
     REDRAW_impl                      20
     SUBPROC_impl                     40
     MyIDLECSMonClose                 48
     LoadDaemons                     152
     MyIDLECSMonCreate                76
     smallicons                        8
     bigicons                          8
     ?<Constant "4:\\ZBin\\Daemons\\">
                                      60
     ESI                              56
     toupper                          14
     ?<Constant "Nothing to run!">    80
     DoUnknownFileType               572
     MyShowMSG                        32
     NEW_ONCREATE                      4
     NEW_ONCLOSE                       4
     NEW_SHOWMSG                       4
     NEW_TXTEXT                        4
     SWILIB_FUNC171                    4
     SWILIB_FUNC172                    4
     ?<Constant "*.elf">               8
     ?<Constant "elf">                 4
     ?<Constant "">                    1
      Others                          76

 
 1 652 bytes in segment CODE
   169 bytes in segment DATA_C
   180 bytes in segment HELPER_PROC
     8 bytes in segment HELPER_PROC_DATA
     4 bytes in segment PATCH_ONCLOSE
     4 bytes in segment PATCH_ONCREATE
     4 bytes in segment PATCH_SHOWMSG_BLF
     4 bytes in segment PATCH_TXT_EXT
     4 bytes in segment SWILIB_FUNC171
     4 bytes in segment SWILIB_FUNC172
 
 1 756 bytes of CODE  memory (+ 76 bytes shared)
   201 bytes of CONST memory

Errors: none
Warnings: none
